<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crownfall (Official Rules)</title>
    <style>
        :root {
            --p1-color: #2a9d8f; /* Teal */
            --p2-color: #e76f51; /* Orange */
            --background-color: #333;
            --panel-color: #444;
            --board-bg: #555;
            --cell-bg-light: #E0D8B0; /* Beige */
            --cell-bg-dark: #B4B8AB;  /* Light Grey */
            --highlight-move: #a2d2ff;
            --highlight-attack: #ffafcc;
            --highlight-placement: #bde0fe;
            --text-light: #eee;
            --text-dark: #1d3557;
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: var(--background-color); color: var(--text-light); margin: 0; flex-direction: column; }
        .game-container { display: flex; gap: 30px; align-items: flex-start; }
        .info-panel { width: 220px; text-align: center; padding: 10px; background-color: var(--panel-color); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.4); border: 3px solid transparent; transition: all 0.3s ease-in-out; }
        .active-turn-panel { border: 3px solid gold; box-shadow: 0 0 20px gold; transform: scale(1.02); }
        .info-panel h2 { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 10px 0; }
        .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 2px solid #fff; }
        .captured-pieces-display { margin-top: 10px; padding-top: 10px; border-top: 1px solid #666; min-height: 60px; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center;}
        .captured-icon { width: 25px; height: 25px; border-radius: 50%; border: 2px solid black; }
        #game-center { position: relative; }
        #gameBoard { display: grid; grid-template-columns: repeat(7, 60px); grid-template-rows: repeat(5, 60px); border: 3px solid #666; background-color: var(--board-bg); gap: 2px; padding: 2px; border-radius: 5px; transition: opacity 0.5s; }
        .cell { width: 60px; height: 60px; display: flex; justify-content: center; align-items: center; box-sizing: border-box; border: 1px solid #777; position: relative; transition: background-color 0.2s; }

        /* Checkerboard Pattern */
        .cell:nth-child(odd) { background-color: var(--cell-bg-light); }
        .cell:nth-child(even) { background-color: var(--cell-bg-dark); }
        #gameBoard > .cell:nth-child(n+8):nth-child(-n+14):nth-child(odd),
        #gameBoard > .cell:nth-child(n+22):nth-child(-n+28):nth-child(odd),
        #gameBoard > .cell:nth-child(n+36):nth-child(-n+42):nth-child(odd) { background-color: var(--cell-bg-dark); }
        #gameBoard > .cell:nth-child(n+8):nth-child(-n+14):nth-child(even),
        #gameBoard > .cell:nth-child(n+22):nth-child(-n+28):nth-child(even),
        #gameBoard > .cell:nth-child(n+36):nth-child(-n+42):nth-child(even) { background-color: var(--cell-bg-light); }

        .player-piece {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border: 3px solid black;
            box-sizing: border-box;
            transition: all 0.2s ease-in-out;
            position: relative;
        }
       
        .p1-piece { background-color: var(--p1-color); }
        .p2-piece { background-color: var(--p2-color); }
       
        .crowned { box-shadow: 0 0 15px gold; }
        .crowned::after {
            content: '';
            position: absolute;
            width: 80%; height: 80%;
            background-color: gold;
            border-radius: 50%;
            border: 2px solid #444;
            box-sizing: border-box;
            top: 5px; left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
       
        .crown-icon { font-size: 28px; position: absolute; text-shadow: 0 0 3px black; pointer-events: none; z-index: 2; }
        .selected { border: 4px solid #3498db; transform: scale(1.1); }
        .highlight-move { background-color: var(--highlight-move) !important; }
        .highlight-attack { background-color: var(--highlight-attack) !important; }
        .highlight-placement { background-color: var(--highlight-placement) !important; border: 2px dashed #3498db; }
        .player1-crown-spot, .player2-crown-spot { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ðŸ‘‘</text></svg>'); background-size: 70%; background-repeat: no-repeat; background-position: center; opacity: 0.5; }
        #ui-panel { text-align: center; }
        #message { margin: 15px 0; font-size: 1.3em; color: #f1faee; font-weight: bold; min-height: 2em; }
        #rollDisplay { margin-top: 10px; font-size: 1.1em; font-weight: bold; min-height: 25px; color: #a8dadc; }
        #setup-choices { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .choice-group { border: 1px solid #888; padding: 10px; border-radius: 5px; }
        button { padding: 10px 20px; font-size: 1em; margin: 5px; cursor: pointer; border: none; border-radius: 5px; background-color: #457b9d; color: white; transition: background-color 0.2s; }
        button:hover { background-color: #a8dadc; color: var(--text-dark); }
        button:disabled { background-color: #666; color: #999; cursor: not-allowed; }

        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s ease-in-out; }
        .modal.visible { display: flex; opacity: 1; }
        .modal-content { background-color: var(--panel-color); padding: 30px; border: 2px solid gold; width: 80%; max-width: 500px; text-align: center; border-radius: 10px; box-shadow: 0 0 25px rgba(255, 215, 0, 0.5); position: relative; overflow: hidden; }
        .modal-content h2, .modal-content h3 { color: gold; }
        .modal-content p { font-size: 1.2em; }
       
        body.game-over #gameBoard { pointer-events: none; opacity: 0.6; }
        #loserAnimation { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .loser-icon { font-size: 100px; color: #e63946; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; text-shadow: 2px 2px 5px rgba(0,0,0,0.5); }
        .raindrop { position: absolute; bottom: 100%; width: 2px; height: 30px; background: linear-gradient(to bottom, rgba(173, 216, 230, 0), rgba(173, 216, 230, 0.6)); animation: fall linear infinite; z-index: 2;}
        @keyframes fall { to { transform: translateY(200vh); } }

        #dice-modal-content { text-align: center; }
        #dice-container { margin-bottom: 20px; }
        #dice-svg { width: 150px; height: 150px; }
        #dice-svg .face { fill: #f1faee; stroke: #1d3557; stroke-width: 5; }
        #dice-svg .text { font-size: 50px; font-weight: bold; fill: #e63946; text-anchor: middle; dominant-baseline: central; }
        #dice-results { font-size: 1.2em; min-height: 1.5em; }
        #crownChoiceContent h3, #reinforceChoiceContent h3 { font-size: 1.8em; margin-top: 0; color: #fff; }
        #crownChoiceActions button, #reinforceChoiceActions button { margin: 10px; }

        @keyframes roll-animation {
            0% { transform: scale(0.5) rotate(0deg); }
            50% { transform: scale(1.2) rotate(540deg); }
            100% { transform: scale(1) rotate(720deg); }
        }
        .rolling { animation: roll-animation 1s ease-out; }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="p1_panel" class="info-panel">
            <h2><div id="p1_swatch" class="color-swatch"></div> <span id="p1_header"></span></h2>
            <p>Die Type: <b id="p1_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p1_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p1_captured_display" class="captured-pieces-display"></div>
        </div>
        <div id="game-center">
            <h1>Crownfall</h1>
            <div id="gameBoard"></div>
            <div id="ui-panel"><div id="message"></div><div id="rollDisplay"></div><div id="setup-choices"></div><div id="action-buttons"></div></div>
        </div>
        <div id="p2_panel" class="info-panel">
            <h2><div id="p2_swatch" class="color-swatch"></div> <span id="p2_header"></span></h2>
            <p>Die Type: <b id="p2_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p2_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p2_captured_display" class="captured-pieces-display"></div>
        </div>
    </div>
   
    <div id="dice-modal" class="modal"><div id="dice-modal-content" class="modal-content"><h3 id="dice-title">Rolling...</h3><div id="dice-container"><svg id="dice-svg" viewBox="0 0 100 100"><polygon class="face" points="50,1 95,25 95,75 50,99 5,75 5,25" /><text class="text" x="50" y="52">20</text></svg></div><div id="dice-results"></div></div></div>
    <div id="victoryModal" class="modal"><div id="victoryContent" class="modal-content"><div id="loserAnimation" style="display: none;"><div class="loser-icon">ðŸ˜­</div></div><h2 id="victoryTitle"></h2><p id="victoryMessage"></p><div id="victoryActions"></div></div></div>
    <div id="crownChoiceModal" class="modal"><div id="crownChoiceContent" class="modal-content"><h3>You've Reached the Crown Space!</h3><p>You may Double-Stack this piece or place a Reinforcement from your reserve.</p><p>Reserve: <b id="crown-modal-reserve-count">X</b></p><div id="crownChoiceActions"></div></div></div>
    <div id="reinforceChoiceModal" class="modal"><div id="reinforceChoiceContent" class="modal-content"><h3>Choose Reinforcement Location</h3><p>Place a new piece to the left or right of your Crown Space.</p><div id="reinforceChoiceActions"></div></div></div>

    <script>
        const gameBoardElement = document.getElementById('gameBoard');
        const messageElement = document.getElementById('message');
        const rollDisplayElement = document.getElementById('rollDisplay');
        const actionButtonsElement = document.getElementById('action-buttons');
        const setupChoicesElement = document.getElementById('setup-choices');
        let gameState = {};

        const getEl = (id) => document.getElementById(id);
        const rollD20 = () => Math.floor(Math.random() * 20) + 1;
        const getPiece = (id) => gameState.pieces.find(p => p.id === id);
        const getPieceAt = (r, c) => {
            if (isOutOfBounds(r,c)) return null;
            const pieceId = gameState.board[r][c];
            return pieceId ? getPiece(pieceId) : null;
        };
        const isOutOfBounds = (r, c) => r < 0 || r >= gameState.boardSize.rows || c < 0 || c >= gameState.boardSize.cols;
       
        // Corrected Rule: A player cannot land on their own single CROWN SPACE. Other spaces on the home row are fine.
        function isOwnCrownSpace(player, r, c) {
            const ownCrown = gameState.crownSpaces[player];
            return ownCrown.r === r && ownCrown.c === c;
        }

        function movePieceOnBoard(piece, newR, newC) {
            if (!piece) return;
            // Preventative check remains as a final safeguard.
            if (isOwnCrownSpace(piece.owner, newR, newC)) {
                console.error(`CRITICAL ERROR: An illegal move to crown space (${newR}, ${newC}) was attempted and blocked.`);
                return;
            }
            const oldPos = piece.position;
            gameState.board[oldPos.r][oldPos.c] = null;
            gameState.board[newR][newC] = piece.id;
            piece.position = { r: newR, c: newC };
        }

        // --- All other functions up to initializeGame are correct and unchanged ---
        function render() {
            const p1Color = gameState.players.p1.color || 'transparent';
            const p2Color = gameState.players.p2.color || 'transparent';
            document.documentElement.style.setProperty('--p1-color', p1Color);
            document.documentElement.style.setProperty('--p2-color', p2Color);
            getEl('p1_swatch').style.backgroundColor = p1Color;
            getEl('p2_swatch').style.backgroundColor = p2Color;
            const p1Panel = getEl('p1_panel');
            const p2Panel = getEl('p2_panel');
            p1Panel.classList.toggle('active-turn-panel', gameState.turn === 'p1');
            p2Panel.classList.toggle('active-turn-panel', gameState.turn === 'p2');
            getEl('p1_header').textContent = `Player 1`;
            getEl('p2_header').textContent = `Player 2 (Bot)`;
            getEl('p1_die_type').textContent = gameState.players.p1.dieType || 'N/A';
            getEl('p2_die_type').textContent = gameState.players.p2.dieType || 'N/A';
            getEl('p1_reserve').textContent = gameState.players.p1.piecesInReserve;
            getEl('p2_reserve').textContent = gameState.players.p2.piecesInReserve;
            const p1CapturedContainer = getEl('p1_captured_display');
            p1CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p1.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p2Color;
                p1CapturedContainer.appendChild(capturedEl);
            }
            const p2CapturedContainer = getEl('p2_captured_display');
            p2CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p2.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p1Color;
                p2CapturedContainer.appendChild(capturedEl);
            }
            messageElement.textContent = gameState.message;
            rollDisplayElement.textContent = gameState.rollMessage || '';
            gameBoardElement.innerHTML = '';
            for (let r = 0; r < gameState.boardSize.rows; r++) {
                for (let c = 0; c < gameState.boardSize.cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    if (r === gameState.crownSpaces.p1.row && c === gameState.crownSpaces.p1.col) cell.classList.add('player1-crown-spot');
                    if (r === gameState.crownSpaces.p2.row && c === gameState.crownSpaces.p2.col) cell.classList.add('player2-crown-spot');
                    if (gameState.highlightedMoves.some(m => m.r === r && m.c === c)) cell.classList.add('highlight-move');
                    if (gameState.highlightedAttacks.some(a => a.landing.r === r && a.landing.c === c)) cell.classList.add('highlight-attack');
                    if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) cell.classList.add('highlight-placement');
                    const piece = getPieceAt(r, c);
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.classList.add('player-piece', piece.owner === 'p1' ? 'p1-piece' : 'p2-piece');
                        pieceEl.dataset.pieceId = piece.id;
                        if (piece.isCrowned) {
                            pieceEl.classList.add('crowned');
                            const crownIcon = document.createElement('div');
                            crownIcon.classList.add('crown-icon');
                            crownIcon.textContent = 'ðŸ‘‘';
                            pieceEl.appendChild(crownIcon);
                        }
                        if (piece.id === gameState.selectedPieceId) pieceEl.classList.add('selected');
                        cell.appendChild(pieceEl);
                    }
                    gameBoardElement.appendChild(cell);
                }
            }
            setupChoicesElement.innerHTML = '';
            if (gameState.gamePhase === 'SETUP_CHOICE') {
                const colors = ['#2a9d8f', '#e76f51'];
                if (!gameState.players.p1.color) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose Color:</b>';
                    colors.forEach(color => {
                        const button = document.createElement('button');
                        button.textContent = color === '#2a9d8f' ? 'Teal' : 'Orange';
                        button.onclick = () => chooseColor(color);
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
                if (!gameState.players.p1.dieType) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose Die Type:</b>';
                    ['Even', 'Odd'].forEach(type => {
                        const button = document.createElement('button');
                        button.textContent = type;
                        button.onclick = () => chooseDieType(type.toLowerCase());
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
            }
            actionButtonsElement.innerHTML = '';
            gameState.actions.forEach(action => {
                const button = document.createElement('button');
                button.textContent = action.text;
                button.onclick = action.onClick;
                button.disabled = action.disabled || false;
                actionButtonsElement.appendChild(button);
            });
        }
       
        function handleBoardClick(event) {
            if (gameState.gamePhase === 'GAME_OVER') return;
            const pieceEl = event.target.closest('[data-piece-id]');
            const cellEl = event.target.closest('[data-row]');
            if (gameState.gamePhase === 'PLAYING' && gameState.turn === 'p1') {
                if (pieceEl) {
                    const pieceId = parseInt(pieceEl.dataset.pieceId);
                    const piece = getPiece(pieceId);
                    if (piece.owner === 'p1') selectPiece(pieceId);
                } else if (cellEl && gameState.selectedPieceId !== null) {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    declareMoveOrAttack(r, c);
                }
            } else if (gameState.gamePhase === 'SETUP_PLACEMENT') {
                if (cellEl && gameState.placingPlayer === 'p1') {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    placeStartingPiece(r, c);
                }
            }
        }

        function initializeGame() {
            document.body.classList.remove('game-over');
            const loserAnimationContainer = getEl('loserAnimation');
            loserAnimationContainer.style.display = 'none';
            loserAnimationContainer.innerHTML = '<div class="loser-icon">ðŸ˜­</div>';

            gameState = {
                boardSize: { rows: 5, cols: 7 },
                board: Array(5).fill(0).map(() => Array(7).fill(null)),
                pieces: [],
                players: {
                    p1: { id: 'p1', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 },
                    p2: { id: 'p2', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 }
                },
                crownSpaces: { p1: { row: 4, col: 3 }, p2: { row: 0, col: 3 } },
                turn: null, gamePhase: 'SETUP_D20_ROLL', winner: null,
                message: "Let's begin! Roll to start the game.",
                rollMessage: '', selectedPieceId: null,
                highlightedMoves: [], highlightedAttacks: [], highlightedPlacements: [],
                pendingAttack: null, pendingChainJump: null, pieceToCrownId: null,
                actions: [{ text: 'Roll to Start Game', onClick: setupRollOff }]
            };
            getEl('victoryModal').classList.remove('visible');
            getEl('crownChoiceModal').classList.remove('visible');
            getEl('reinforceChoiceModal').classList.remove('visible');
            render();
        }
       
        async function setupRollOff() {
            gameState.actions = [];
            render();
            const p1Result = await showDiceRoll(1, "Player 1 Rolling...", false);
            const p2Result = await showDiceRoll(1, "Bot Rolling...", false);
            const p1Roll = p1Result.rolls[0];
            const p2Roll = p2Result.rolls[0];

            gameState.rollMessage = `Player 1 rolled a ${p1Roll}. Bot rolled a ${p2Roll}.`;
            let firstPlayer;
            if (p1Roll > p2Roll) {
                firstPlayer = 'p1';
                gameState.gamePhase = 'SETUP_CHOICE';
                gameState.message = 'You rolled higher! You will move first. Choose your color and die type.';
            } else if (p2Roll > p1Roll) {
                firstPlayer = 'p2';
                const botColor = Math.random() < 0.5 ? '#2a9d8f' : '#e76f51';
                const botDieType = Math.random() < 0.5 ? 'even' : 'odd';
                gameState.players.p2.color = botColor;
                gameState.players.p2.dieType = botDieType;
                gameState.players.p1.color = botColor === '#2a9d8f' ? '#e76f51' : '#2a9d8f';
                gameState.players.p1.dieType = botDieType === 'even' ? 'odd' : 'even';
                gameState.message = `Bot rolled higher and will move first. Bot has chosen its settings.`;
                startPlacementPhase(firstPlayer);
            } else {
                gameState.message = "It's a tie! Roll again.";
                gameState.actions = [{ text: 'Roll to Start Game', onClick: setupRollOff }];
            }
            gameState.turn = firstPlayer;
            render();
        }

        function chooseColor(color) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.color) return;
            gameState.players.p1.color = color;
            gameState.players.p2.color = color === '#2a9d8f' ? '#e76f51' : '#2a9d8f';
            checkSetupChoices();
        }
        function chooseDieType(type) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.dieType) return;
            gameState.players.p1.dieType = type;
            gameState.players.p2.dieType = type === 'even' ? 'odd' : 'even';
            checkSetupChoices();
        }
        function checkSetupChoices() {
            if (gameState.players.p1.color && gameState.players.p1.dieType) {
                startPlacementPhase(gameState.turn);
            }
            render();
        }

        function startPlacementPhase(firstPlayer) {
            gameState.gamePhase = 'SETUP_PLACEMENT';
            gameState.placingPlayer = firstPlayer;
            gameState.piecesToPlace = 4;
            gameState.actions = [];
            if (firstPlayer === 'p2') {
                placeBotStartingPieces();
                gameState.placingPlayer = 'p1';
                gameState.message = "Bot has placed its pieces. Now, place your 4 pieces on your starting row.";
            } else {
                gameState.message = 'Your turn to place 4 pieces on the starting row.';
            }
            highlightPlacementSpots();
            render();
        }
       
        function highlightPlacementSpots() {
            gameState.highlightedPlacements = [];
            const player = gameState.placingPlayer;
            const startRow = player === 'p1' ? gameState.boardSize.rows - 1 : 0;
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                if (!isOwnCrownSpace(player, startRow, c) && gameState.board[startRow][c] === null) {
                    gameState.highlightedPlacements.push({ r: startRow, c });
                }
            }
        }
       
        function placeStartingPiece(r, c) {
            if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) {
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p1', isCrowned: false, position: { r, c } });
                gameState.board[r][c] = newId;
                gameState.players.p1.piecesInReserve--;
                gameState.piecesToPlace--;
                gameState.message = `Placed piece. ${gameState.piecesToPlace} remaining.`;
                if (gameState.piecesToPlace === 0) {
                    if (gameState.pieces.filter(p => p.owner === 'p2').length === 0) { placeBotStartingPieces(); }
                    setTimeout(startGame, 500);
                }
                highlightPlacementSpots();
                render();
            }
        }
       
        function placeBotStartingPieces() {
            const startRow = 0;
            const validCols = [];
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                 if (!isOwnCrownSpace('p2', startRow, c)) {
                    validCols.push(c);
                }
            }

            let placed = 0;
            while (placed < 4 && validCols.length > 0) {
                const randIndex = Math.floor(Math.random() * validCols.length);
                const c = validCols.splice(randIndex, 1)[0];
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p2', isCrowned: false, position: { r: startRow, c } });
                gameState.board[startRow][c] = newId;
                gameState.players.p2.piecesInReserve--;
                placed++;
            }
        }

        function startGame() {
            gameState.gamePhase = 'PLAYING';
            gameState.highlightedPlacements = [];
            if (gameState.turn === 'p2') {
                gameState.message = `Bot moves first.`;
                setTimeout(botTurn, 1000);
            } else {
                gameState.message = `You move first. Select a piece.`;
            }
            gameState.actions = [];
            render();
        }

        function selectPiece(pieceId) {
            if (gameState.pendingChainJump || gameState.gamePhase !== 'PLAYING') return;
            if (gameState.selectedPieceId === pieceId) {
                gameState.selectedPieceId = null;
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
                gameState.actions = [];
            } else {
                gameState.selectedPieceId = pieceId;
                const piece = getPiece(pieceId);
                const {r, c} = piece.position;
               
                // Highlight Moves
                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                gameState.highlightedMoves = moves.filter(m => {
                    const opponentId = piece.owner === 'p1' ? 'p2' : 'p1';
                    const opponentCrownSpace = gameState.crownSpaces[opponentId];
                    // Rule: Cannot re-enter opponent's crown space if already crowned
                    if (piece.isCrowned && m.r === opponentCrownSpace.r && m.c === opponentCrownSpace.c) {
                        return false;
                    }
                    return !isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace(piece.owner, m.r, m.c);
                });
               
                // Highlight Attacks
                const attacks = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                gameState.highlightedAttacks = [];
                for (const attackDir of attacks) {
                    const targetPos = {r: r + attackDir.dr, c: c + attackDir.dc};
                    const landingPos = {r: r + attackDir.dr * 2, c: c + attackDir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                   
                    const opponentId = piece.owner === 'p1' ? 'p2' : 'p1';
                    const opponentCrownSpace = gameState.crownSpaces[opponentId];
                    let isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) &&
                                           !getPieceAt(landingPos.r, landingPos.c) &&
                                           !isOwnCrownSpace(piece.owner, landingPos.r, landingPos.c);

                    // Rule: Cannot re-enter opponent's crown space if already crowned
                    if (piece.isCrowned && landingPos.r === opponentCrownSpace.r && landingPos.c === opponentCrownSpace.c) {
                        isValidLanding = false;
                    }

                    if (targetPiece && targetPiece.owner !== piece.owner && isValidLanding) {
                        gameState.highlightedAttacks.push({ target: targetPos, landing: landingPos, dir: attackDir });
                    }
                }
               
                gameState.actions = [];
                if (piece.isCrowned && gameState.highlightedAttacks.length > 0) {
                     gameState.actions.push({ text: 'Declare Chain Jump', onClick: () => declareChainJump() });
                }
            }
            render();
        }
       
        function declareChainJump() {
            if (!gameState.selectedPieceId) return;
            const piece = getPiece(gameState.selectedPieceId);
            if (!piece.isCrowned || gameState.highlightedAttacks.length === 0) return;

            gameState.pendingChainJump = { pieceId: gameState.selectedPieceId };
            gameState.message = "Chain Jump declared! Click a highlighted square to perform the first attack.";
            gameState.actions = [{ text: "Cancel Chain Jump", onClick: () => {
                gameState.pendingChainJump = null;
                selectPiece(gameState.selectedPieceId);
            }}];
            render();
        }

        function declareMoveOrAttack(r, c) {
            const attack = gameState.highlightedAttacks.find(a => a.landing.r === r && a.landing.c === c);
            const move = gameState.highlightedMoves.find(m => m.r === r && m.c === c);

            if (gameState.pendingChainJump) {
                if(attack) {
                    gameState.pendingChainJump.targetPos = attack.target;
                    gameState.pendingChainJump.landingPos = attack.landing;
                    gameState.pendingChainJump.dir = attack.dir;
                    gameState.message = "Roll to start your Chain Jump attack!";
                    gameState.actions = [{ text: "Roll to Attack", onClick: executeAttack }];
                    gameState.highlightedMoves = [];
                    gameState.highlightedAttacks = [];
                }
            } else if (move) {
                executeMove(gameState.selectedPieceId, move.r, move.c);
            } else if (attack) {
                gameState.pendingAttack = { pieceId: gameState.selectedPieceId, targetPos: attack.target, landingPos: attack.landing };
                gameState.message = "You have declared an attack!";
                gameState.actions = [{ text: "Roll to Attack", onClick: executeAttack }];
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
            }
            render();
        }
       
        function executeMove(pieceId, r, c) {
            const piece = getPiece(pieceId);
            movePieceOnBoard(piece, r, c);
           
            const opponentId = piece.owner === 'p1' ? 'p2' : 'p1';
            const opponentCrownSpace = gameState.crownSpaces[opponentId];

            if (r === opponentCrownSpace.r && c === opponentCrownSpace.c) {
                enterCrowningPhase(pieceId);
            } else {
                endTurn();
            }
        }
       
        // Corrected Attack Roll Logic
        async function executeAttack() {
            const isChainJump = !!gameState.pendingChainJump;
            const attackData = isChainJump ? gameState.pendingChainJump : gameState.pendingAttack;
            if (!attackData) return;

            const { pieceId, targetPos, landingPos } = attackData;
            gameState.pendingAttack = null;
            gameState.actions = [];
            render();

            const attacker = getPiece(pieceId);
            const defender = getPieceAt(targetPos.r, targetPos.c);
           
            let numRolls = 1; // Default
            if (attacker.isCrowned && defender.isCrowned) numRolls = 7;
            else if (!attacker.isCrowned && defender.isCrowned) numRolls = 3;
            // The case of Crowned vs Standard (numRolls = 1) is handled by the default
           
            const result = await showDiceRoll(numRolls, `${attacker.owner === 'p1' ? 'Player 1' : 'Bot'} Attacking...`, true, attacker.owner);
            const { successes, defenderSuccesses } = result;

            if (isChainJump) {
                if (successes >= 1) {
                    resolveChainJump(attackData);
                } else {
                    gameState.message = "Chain Jump failed! The first attack was unsuccessful.";
                    gameState.pendingChainJump = null;
                    setTimeout(endTurn, 2000);
                }
                return;
            }

            let attackSucceeded = false;
            let message = "";
           
            if (!attacker.isCrowned && !defender.isCrowned) {
                if (successes >= 1) { attackSucceeded = true; message = "Attack successful!"; }
                else { message = "Attack failed!"; }
            } else if (!attacker.isCrowned && defender.isCrowned) {
                if (successes >= 2) {
                    defender.isCrowned = false;
                    message = "Attack successful! Defender is uncrowned.";
                } else {
                    message = "Attack failed! Defender is safe.";
                }
            } else if (attacker.isCrowned && defender.isCrowned) {
                if (successes >= 4) {
                    defender.isCrowned = false;
                    message = "Crowned attack successful! Defender is uncrowned.";
                } else if (defenderSuccesses >= 4) {
                    attacker.isCrowned = false;
                    message = "Crowned attack FAILED! Defender wins. Your piece is uncrowned.";
                } else {
                    message = `Roll-off is a draw (${successes} to ${defenderSuccesses}). No pieces are changed.`;
                }
            } else if (attacker.isCrowned && !defender.isCrowned) {
                if (successes >= 1) { attackSucceeded = true; message = "Crowned attack successful!"; }
                else { message = "Crowned attack failed!"; }
            }

            gameState.message = message;
            if (attackSucceeded) {
                gameState.players[attacker.owner].capturedOpponentPieces++;
                gameState.board[targetPos.r][targetPos.c] = null;
                gameState.pieces = gameState.pieces.filter(p => p.id !== defender.id);
                movePieceOnBoard(attacker, landingPos.r, landingPos.c);

                const opponentId = attacker.owner === 'p1' ? 'p2' : 'p1';
                const opponentCrownSpace = gameState.crownSpaces[opponentId];
                if (landingPos.r === opponentCrownSpace.r && landingPos.c === opponentCrownSpace.c) {
                    enterCrowningPhase(attacker.id);
                } else {
                     setTimeout(endTurn, 2000);
                }
            } else {
                 setTimeout(endTurn, 2000);
            }
        }

        function resolveChainJump(attackData) {
            const { pieceId, targetPos, landingPos, dir } = attackData;
            const attacker = getPiece(pieceId);
            const defender = getPieceAt(targetPos.r, targetPos.c);

            gameState.players[attacker.owner].capturedOpponentPieces++;
            gameState.board[targetPos.r][targetPos.c] = null;
            gameState.pieces = gameState.pieces.filter(p => p.id !== defender.id);
            gameState.board[attacker.position.r][attacker.position.c] = null;
            attacker.isCrowned = false;
            movePieceOnBoard(attacker, landingPos.r, landingPos.c);
           
            const secondLandingPos = { r: landingPos.r + dir.dr, c: landingPos.c + dir.dc };
            const isSecondJumpBlocked = isOutOfBounds(secondLandingPos.r, secondLandingPos.c) ||
                                       getPieceAt(secondLandingPos.r, secondLandingPos.c) ||
                                       isOwnCrownSpace(attacker.owner, secondLandingPos.r, secondLandingPos.c);
           
            let newPieceId = null;
            if (isSecondJumpBlocked) {
                 gameState.message = "Chain jump successful, but the second jump was blocked!";
            } else {
                newPieceId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
                gameState.pieces.push({ id: newPieceId, owner: attacker.owner, isCrowned: false, position: secondLandingPos });
                gameState.board[secondLandingPos.r][secondLandingPos.c] = newPieceId;
                gameState.message = "Chain jump successful! The piece has split.";
            }
           
            gameState.pendingChainJump = null;
            const opponentId = attacker.owner === 'p1' ? 'p2' : 'p1';
            const opponentCrownSpace = gameState.crownSpaces[opponentId];
            if (landingPos.r === opponentCrownSpace.r && landingPos.c === opponentCrownSpace.c) {
                enterCrowningPhase(attacker.id);
            } else if (newPieceId && secondLandingPos.r === opponentCrownSpace.r && secondLandingPos.c === opponentCrownSpace.c) {
                enterCrowningPhase(newPieceId);
            } else {
                setTimeout(endTurn, 2500);
            }
        }
       
        function promptReinforceChoice() {
            getEl('crownChoiceModal').classList.remove('visible');
            const reinforceModal = getEl('reinforceChoiceModal');
            const actionsContainer = getEl('reinforceChoiceActions');
            actionsContainer.innerHTML = '';
           
            const player = gameState.turn;
            const ownCrownSpace = gameState.crownSpaces[player];
            const leftSpotFree = !isOutOfBounds(ownCrownSpace.r, ownCrownSpace.c - 1) && !getPieceAt(ownCrownSpace.r, ownCrownSpace.c - 1);
            const rightSpotFree = !isOutOfBounds(ownCrownSpace.r, ownCrownSpace.c + 1) && !getPieceAt(ownCrownSpace.r, ownCrownSpace.c + 1);

            if (leftSpotFree) {
                const leftButton = document.createElement('button');
                leftButton.textContent = "Place Left";
                leftButton.onclick = () => {
                    reinforceModal.classList.remove('visible');
                    resolveCrowning('reinforce', 'left');
                };
                actionsContainer.appendChild(leftButton);
            }
            if (rightSpotFree) {
                const rightButton = document.createElement('button');
                rightButton.textContent = "Place Right";
                rightButton.onclick = () => {
                    reinforceModal.classList.remove('visible');
                    resolveCrowning('reinforce', 'right');
                };
                actionsContainer.appendChild(rightButton);
            }
            if (!leftSpotFree && !rightSpotFree) {
                actionsContainer.innerHTML = "<p>No available space to place a reinforcement.</p>";
                setTimeout(() => {
                    reinforceModal.classList.remove('visible');
                    endTurn();
                }, 2000);
            }
            reinforceModal.classList.add('visible');
        }

        function enterCrowningPhase(pieceId) {
            gameState.gamePhase = 'AWAITING_CROWNING_CHOICE';
            gameState.pieceToCrownId = pieceId;
            const player = getPiece(pieceId).owner;
            const playerObj = gameState.players[player];
            const hasReserves = playerObj.piecesInReserve > 0;
           
            gameState.message = `${player === 'p1' ? 'You have' : 'Bot has'} reached the opponent's crown space!`;
            gameState.actions = [];
            render();

            if (player === 'p1') {
                const crownModal = getEl('crownChoiceModal');
                const actionsContainer = getEl('crownChoiceActions');
                actionsContainer.innerHTML = '';
                getEl('crown-modal-reserve-count').textContent = playerObj.piecesInReserve;
               
                const crownButton = document.createElement('button');
                crownButton.textContent = "Double-Stack";
                crownButton.onclick = () => { crownModal.classList.remove('visible'); resolveCrowning('crown'); };
                crownButton.disabled = !hasReserves;
                actionsContainer.appendChild(crownButton);

                const reinforceButton = document.createElement('button');
                reinforceButton.textContent = "Place Reinforcement";
                reinforceButton.onclick = () => promptReinforceChoice();
                reinforceButton.disabled = !hasReserves;
                actionsContainer.appendChild(reinforceButton);
               
                if (!hasReserves) {
                    const noActionInfo = document.createElement('p');
                    noActionInfo.textContent = "You have no pieces in reserve to take an action.";
                    actionsContainer.appendChild(noActionInfo);
                     setTimeout(() => { crownModal.classList.remove('visible'); resolveCrowning('none'); }, 2500);
                }
                crownModal.classList.add('visible');
            } else {
                setTimeout(() => {
                    const ownCrownSpace = gameState.crownSpaces.p2;
                    const leftSpotFree = !getPieceAt(ownCrownSpace.r, ownCrownSpace.c - 1);
                    const rightSpotFree = !getPieceAt(ownCrownSpace.r, ownCrownSpace.c + 1);
                    const canReinforce = hasReserves && (leftSpotFree || rightSpotFree);
                   
                    if (canReinforce) {
                        const availableDirections = [];
                        if (leftSpotFree) availableDirections.push('left');
                        if (rightSpotFree) availableDirections.push('right');
                        const direction = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                        resolveCrowning('reinforce', direction);
                    } else if (hasReserves) {
                        resolveCrowning('crown');
                    } else {
                        resolveCrowning('none');
                    }
                }, 1500);
            }
        }

        function resolveCrowning(choice, direction = null) {
            const piece = getPiece(gameState.pieceToCrownId);
            if (!piece) { endTurn(); return; }
            const player = piece.owner;
            const playerObj = gameState.players[player];

            if (choice === 'crown') {
                piece.isCrowned = true;
                playerObj.piecesInReserve--;
                gameState.message = `${player === 'p1' ? 'Your' : "The Bot's"} piece has been Double-Stacked!`;
            } else if (choice === 'reinforce' && direction) {
                const ownCrownSpace = gameState.crownSpaces[player];
                const placementCol = direction === 'left' ? ownCrownSpace.c - 1 : ownCrownSpace.c + 1;
               
                const newId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
                gameState.pieces.push({ id: newId, owner: player, isCrowned: false, position: { r: ownCrownSpace.row, c: placementCol } });
                gameState.board[ownCrownSpace.row][placementCol] = newId;
                playerObj.piecesInReserve--;
                gameState.message = `${player === 'p1' ? 'You' : "The Bot"} placed a reinforcement to the ${direction} of ${player === 'p1' ? 'your' : "its"} crown.`;
            } else {
                 gameState.message = "No reserve action was taken.";
            }
            gameState.gamePhase = 'PLAYING';
            gameState.pieceToCrownId = null;
            endTurn();
        }

        function checkForWin() {
            if (gameState.pieces.filter(p => p.owner === 'p1').length === 0) { setWinner('p2', 'The Bot eliminated all of your pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p2').length === 0) { setWinner('p1', 'You eliminated all opponent pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p1' && p.isCrowned).length >= 4) { setWinner('p1', 'You have 4 crowned pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p2' && p.isCrowned).length >= 4) { setWinner('p2', 'The Bot has 4 crowned pieces!'); return true; }
            return false;
        }

        function setWinner(winner, message) {
            gameState.gamePhase = 'GAME_OVER';
            gameState.winner = winner;
            document.body.classList.add('game-over');

            const modal = getEl('victoryModal');
            getEl('victoryTitle').textContent = winner === 'p1' ? 'VICTORY!' : 'DEFEAT!';
            getEl('victoryMessage').textContent = message;

            if (winner === 'p2') {
                const animationContainer = getEl('loserAnimation');
                animationContainer.style.display = 'block';
                for (let i = 0; i < 50; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'raindrop';
                    drop.style.left = Math.random() * 100 + '%';
                    drop.style.animationDelay = Math.random() * 2 + 's';
                    drop.style.animationDuration = 0.5 + Math.random() * 0.5 + 's';
                    animationContainer.appendChild(drop);
                }
            }
           
            const actions = getEl('victoryActions');
            actions.innerHTML = '';
            const button = document.createElement('button');
            button.textContent = "Play Again?";
            button.onclick = initializeGame;
            actions.appendChild(button);
            modal.classList.add('visible');
            render();
        }

        function endTurn() {
            gameState.selectedPieceId = null;
            gameState.highlightedMoves = [];
            gameState.highlightedAttacks = [];
            gameState.actions = [];
           
            if (checkForWin()) return;

            gameState.turn = gameState.turn === 'p1' ? 'p2' : 'p1';
            gameState.message = `${gameState.turn === 'p1' ? 'Your' : "Bot's"} turn to move.`;
            gameState.rollMessage = '';
            render();
            if (gameState.turn === 'p2' && gameState.gamePhase === 'PLAYING') setTimeout(botTurn, 2000);
        }
       
        function botTurn() {
            const myPieces = gameState.pieces.filter(p => p.owner === 'p2');
            let possibleActions = [];
            myPieces.forEach(piece => {
                const {r, c} = piece.position;
               
                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                moves.forEach(m => {
                    const opponentCrownSpace = gameState.crownSpaces.p1;
                     if (piece.isCrowned && m.r === opponentCrownSpace.r && m.c === opponentCrownSpace.c) return;
                    if (!isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace('p2', m.r, m.c)) {
                        possibleActions.push({ type: 'move', pieceId: piece.id, r: m.r, c: m.c });
                    }
                });

                const attacks = [{dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1}];
                for (const dir of attacks) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                   
                    const opponentCrownSpace = gameState.crownSpaces.p1;
                    let isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) &&
                                           !getPieceAt(landingPos.r, landingPos.c) &&
                                           !isOwnCrownSpace('p2', landingPos.r, landingPos.c);
                    if (piece.isCrowned && landingPos.r === opponentCrownSpace.r && landingPos.c === opponentCrownSpace.c) isValidLanding = false;

                    if(targetPiece && targetPiece.owner === 'p1' && isValidLanding){
                        possibleActions.push({ type: 'attack', pieceId: piece.id, targetPos, landingPos });
                    }
                }
            });

            if (possibleActions.length > 0) {
                const attackActions = possibleActions.filter(a => a.type === 'attack');
                const moveActions = possibleActions.filter(a => a.type === 'move');
                const chosenAction = attackActions.length > 0
                    ? attackActions[Math.floor(Math.random() * attackActions.length)]
                    : moveActions[Math.floor(Math.random() * moveActions.length)];
               
                if (chosenAction.type === 'move') {
                    executeMove(chosenAction.pieceId, chosenAction.r, chosenAction.c);
                } else {
                    gameState.pendingAttack = chosenAction;
                    executeAttack();
                }
            } else {
                gameState.message = "Bot has no valid moves.";
                setTimeout(endTurn, 1500);
            }
        }

        function showDiceRoll(rollsNeeded, title, calculateSuccesses = true, attackerId) {
            return new Promise(resolve => {
                const modal = getEl('dice-modal');
                const svg = getEl('dice-svg');
                const text = svg.querySelector('.text');
                getEl('dice-title').textContent = title || 'Rolling...';
                const resultsEl = getEl('dice-results');
                resultsEl.innerHTML = '';
                modal.classList.add('visible');
                svg.classList.add('rolling');
                let tumbleInterval = setInterval(() => { text.textContent = Math.floor(Math.random() * 20) + 1; }, 60);
                setTimeout(() => {
                    clearInterval(tumbleInterval);
                    svg.classList.remove('rolling');
                    const rolls = Array(rollsNeeded).fill(0).map(() => rollD20());
                    let successes = 0, defenderSuccesses = 0;
                    if (calculateSuccesses) {
                        const attackerDieType = gameState.players[attackerId].dieType;
                        const defenderId = attackerId === 'p1' ? 'p2' : 'p1';
                        const defenderDieType = gameState.players[defenderId].dieType;
                        successes = rolls.filter(r => (attackerDieType === 'even' && r % 2 === 0) || (attackerDieType === 'odd' && r % 2 !== 0)).length;
                        if(numRolls > 1) { // Only calculate defender successes in a roll-off
                            defenderSuccesses = rolls.filter(r => (defenderDieType === 'even' && r % 2 === 0) || (defenderDieType === 'odd' && r % 2 !== 0)).length;
                        }
                        let resultsText = `Rolls: ${rolls.join(', ')}`;
                        resultsText += `<br> Attacker Successes: ${successes}`;
                        if (numRolls > 1) resultsText += `<br> Defender Successes: ${defenderSuccesses}`;
                        resultsEl.innerHTML = resultsText;
                    } else {
                        resultsEl.innerHTML = `Roll: ${rolls[0]}`;
                    }
                    text.textContent = rolls[0];
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        resolve({ rolls, successes, defenderSuccesses });
                    }, 2500);
                }, 1000);
            });
        }

        gameBoardElement.addEventListener('click', handleBoardClick);
        initializeGame();
    </script>
</body>
</html>
