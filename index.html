<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crownfall (Official Rules)</title>
    <style>
        :root {
            --p1-color: #0096C7; /* Cerulean */
            --p2-color: #FF9F1C; /* Bright Orange */
            --background-color: #333;
            --panel-color: #444;
            --board-bg: #555;
            --cell-bg-light: #E0D8B0; /* Beige */
            --cell-bg-dark: #B4B8AB;  /* Light Grey */
            --highlight-move: #a2d2ff;
            --highlight-attack: #ffafcc;
            --highlight-pending-attack: #c9184a; /* Darker Red */
            --highlight-double-stack: #9b59b6; /* Purple */
            --highlight-placement: #bde0fe;
            --text-light: #eee;
            --text-dark: #1d3557;

            /* Sizing Variables for Responsiveness */
            --cell-size: 60px;
            --piece-size: 45px;
            --label-size: 30px;
            --crowned-ring-size: calc(var(--piece-size) * 0.8);
            --crowned-ring-top: calc((var(--piece-size) - var(--crowned-ring-size)) / 2);
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: var(--background-color); color: var(--text-light); margin: 0; flex-direction: column; padding: 10px; box-sizing: border-box; }
        .game-container { display: flex; gap: 30px; align-items: flex-start; width: 100%; justify-content: center; }
        .info-panel { width: 220px; text-align: center; padding: 10px; background-color: var(--panel-color); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.4); border: 3px solid transparent; transition: all 0.3s ease-in-out; }
        .active-turn-panel { border: 3px solid gold; box-shadow: 0 0 20px gold; transform: scale(1.02); }
        .info-panel h2 { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 10px 0; }
        .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 2px solid #fff; }
        .captured-pieces-display { margin-top: 10px; padding-top: 10px; border-top: 1px solid #666; min-height: 60px; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center;}
        .captured-icon { width: 25px; height: 25px; border-radius: 50%; border: 2px solid black; }
        #game-center { position: relative; display: flex; flex-direction: column; align-items: center; }

        #board-container {
            display: grid;
            grid-template-columns: var(--label-size) 1fr;
            grid-template-rows: var(--label-size) 1fr;
            grid-template-areas:
                ". col-headers"
                "row-headers game-board";
            align-items: center;
            justify-items: center;
            margin-top: 10px;
        }
        .grid-label { font-weight: bold; color: #ccc; }
        #col-headers { grid-area: col-headers; display: flex; width: 100%; }
        #col-headers .grid-label { width: calc(var(--cell-size) + 2px); text-align: center; }
        #row-headers { grid-area: row-headers; display: flex; flex-direction: column; height: 100%; }
        #row-headers .grid-label { height: calc(var(--cell-size) + 2px); display: flex; align-items: center; justify-content: center; }
        #gameBoard { grid-area: game-board; display: grid; grid-template-columns: repeat(7, var(--cell-size)); grid-template-rows: repeat(5, var(--cell-size)); border: 3px solid #666; background-color: var(--board-bg); gap: 2px; padding: 2px; border-radius: 5px; transition: opacity 0.5s; }

        .cell { width: var(--cell-size); height: var(--cell-size); display: flex; justify-content: center; align-items: center; box-sizing: border-box; border: 1px solid #777; position: relative; transition: background-color 0.2s; }
       
        .player-piece {
            width: var(--piece-size);
            height: var(--piece-size);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border: 3px solid black;
            box-sizing: border-box;
            transition: all 0.2s ease-in-out;
            position: relative;
        }
       
        .p1-piece { background-color: var(--p1-color); }
        .p2-piece { background-color: var(--p2-color); }
       
        .crowned { box-shadow: 0 0 15px gold; }
        .crowned::after {
            content: '';
            position: absolute;
            width: var(--crowned-ring-size); height: var(--crowned-ring-size);
            background-color: gold;
            border-radius: 50%;
            border: 2px solid #444;
            box-sizing: border-box;
            top: var(--crowned-ring-top); left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
       
        .crown-icon { font-size: calc(var(--piece-size) * 0.7); position: absolute; text-shadow: 0 0 3px black; pointer-events: none; z-index: 2; }
        .selected { border: 4px solid #3498db; transform: scale(1.1); }
        .highlight-move { background-color: var(--highlight-move) !important; }
        .highlight-attack { background-color: var(--highlight-attack) !important; }
        .highlight-pending-attack { background-color: var(--highlight-pending-attack) !important; }
        .highlight-double-stack { background-color: var(--highlight-double-stack) !important; }
        .highlight-placement { background-color: var(--highlight-placement) !important; border: 2px dashed #3498db; }
        .player1-crown-spot, .player2-crown-spot { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">üëë</text></svg>'); background-size: 70%; background-repeat: no-repeat; background-position: center; opacity: 0.5; }
        #ui-panel { text-align: center; }
        #message { margin: 15px 0; font-size: 1.3em; color: #f1faee; font-weight: bold; min-height: 2em; }
        #rollDisplay { margin-top: 10px; font-size: 1.1em; font-weight: bold; min-height: 25px; color: #a8dadc; }
        #setup-choices { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .choice-group { border: 1px solid #888; padding: 10px; border-radius: 5px; }
        button { padding: 10px 20px; font-size: 1em; margin: 5px; cursor: pointer; border: none; border-radius: 5px; background-color: #457b9d; color: white; transition: background-color 0.2s; }
        button:hover { background-color: #a8dadc; color: var(--text-dark); }
        button:disabled { background-color: #666; color: #999; cursor: not-allowed; }
       
        #permanent-actions { margin-top: 15px; }
        #quitButton { background-color: #c1121f; }
        #quitButton:hover { background-color: #fca311; }
        #quitConfirmActions button { margin: 10px; }

        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s ease-in-out; }
        .modal.visible { display: flex; opacity: 1; }
        .modal-content { background-color: var(--panel-color); padding: 30px; border: 2px solid #888; width: 90%; max-width: 600px; text-align: center; border-radius: 10px; box-shadow: 0 0 25px rgba(0,0,0, 0.5); position: relative; overflow: hidden; }
        .modal-content h2, .modal-content h3 { color: #eee; }
        .modal-content p { font-size: 1.2em; }
       
        body.game-over #gameBoard { pointer-events: none; opacity: 0.6; }
        #loserAnimation { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .loser-icon { font-size: 80px; color: #e63946; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; text-shadow: 2px 2px 5px rgba(0,0,0,0.5); }
        .raindrop { position: absolute; bottom: 100%; width: 2px; height: 30px; background: linear-gradient(to bottom, rgba(173, 216, 230, 0), rgba(173, 216, 230, 0.6)); animation: fall linear infinite; z-index: 2;}
        @keyframes fall { to { transform: translateY(200vh); } }

        #fireworks-container {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            opacity: 0;
            animation: firework-anim 1.2s ease-out forwards;
        }
        @keyframes firework-anim {
            0% {
                opacity: 1;
                transform: scale(0.3);
                box-shadow: 0 0 5px 3px gold, 0 0 0 5px var(--p2-color), 0 0 0 10px var(--p1-color), 0 0 0 15px #ffafcc;
            }
            100% {
                opacity: 0;
                transform: scale(1.5);
                box-shadow: 0 0 10px 20px transparent, 0 0 0 30px transparent, 0 0 0 50px transparent, 0 0 0 70px transparent;
            }
        }

        #dice-modal-content { text-align: center; }
        #dice-container { margin-bottom: 20px; }
        #dice-svg { width: 150px; height: 150px; }
        #dice-svg .face { fill: #f1faee; stroke: #1d3557; stroke-width: 5; }
        #dice-svg .text { font-size: 50px; font-weight: bold; fill: #e63946; text-anchor: middle; dominant-baseline: central; }
        #dice-results { font-size: 1.2em; min-height: 1.5em; }
        #crownChoiceContent h3, #reinforceChoiceContent h3 { font-size: 1.8em; margin-top: 0; color: #fff; }
        #crownChoiceActions button, #reinforceChoiceActions button { margin: 10px; }

        @keyframes roll-animation {
            0% { transform: scale(0.5) rotate(0deg); }
            50% { transform: scale(1.2) rotate(540deg); }
            100% { transform: scale(1) rotate(720deg); }
        }
        .rolling { animation: roll-animation 1s ease-out; }
       
        .floating-button {
            width: 60px; height: 60px;
            color: white; border-radius: 50%; border: 2px solid white;
            display: flex; justify-content: center; align-items: center;
            font-size: 30px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4); z-index: 101;
            transition: all 0.2s ease-in-out; position: fixed;
        }
        #help-button { bottom: 20px; right: 20px; background-color: #457b9d; }
        #help-button:hover { transform: scale(1.1); background-color: #a8dadc; color: #1d3557; }
       
        #ai-button { bottom: 20px; right: 100px; background-color: #e63946; }
        #ai-button:hover { transform: scale(1.1); background-color: #f1faee; color: #e63946;}
        #ai-chat-display {
            height: 300px; background-color: var(--background-color); border: 1px solid #666;
            border-radius: 5px; padding: 10px; overflow-y: auto;
            display: flex; flex-direction: column; gap: 10px; text-align: left;
        }
        .chat-message { padding: 8px 12px; border-radius: 15px; max-width: 80%; line-height: 1.4; word-wrap: break-word; }
        .user-message { background-color: #457b9d; color: white; align-self: flex-end; border-bottom-right-radius: 3px; }
        .ai-message { background-color: #666; color: white; align-self: flex-start; border-bottom-left-radius: 3px; }
        .ai-message ul { margin: 5px 0 5px 20px; padding: 0; }
        .ai-message li { margin-bottom: 5px; }
       
        #rules-content { text-align: left; padding: 0 20px; max-height: 70vh; overflow-y: auto; }
        #rules-content h3 { border-bottom: 1px solid #666; padding-bottom: 5px; margin-top: 20px; }
        #rules-content h4 { margin-bottom: 5px; margin-top: 15px; color: #a8dadc; }
        #rules-content ul, #rules-content ol { padding-left: 20px; margin-top: 5px; }
        #rules-content li { margin-bottom: 8px; }

        .modal-close-button {
            position: absolute; top: 10px; right: 15px;
            font-size: 30px; font-weight: bold; color: #ccc; cursor: pointer;
        }
        .modal-close-button:hover { color: white; }

        @media (max-width: 768px) {
            :root {
                --cell-size: 45px;
                --piece-size: 35px;
                --label-size: 20px;
            }
            body { padding: 5px; }
            .game-container { flex-direction: column; align-items: center; gap: 15px; }
            .info-panel { width: 95%; max-width: 400px; order: 1; }
            #game-center { order: 2; }
            #p1_panel { order: 1; }
            #game-center { order: 2; }
            #p2_panel { order: 3; }

            .floating-button { width: 50px; height: 50px; font-size: 24px; }
             #help-button { right: 15px; bottom: 15px; }
             #ai-button { right: 80px; bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="p1_panel" class="info-panel">
            <h2><div id="p1_swatch" class="color-swatch"></div> <span id="p1_header"></span></h2>
            <p>Difficulty: <b id="p1_difficulty"></b></p>
            <p>D20 Numbers: <b id="p1_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p1_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p1_captured_display" class="captured-pieces-display"></div>
        </div>
        <div id="game-center">
            <h1>Crownfall</h1>
            <div id="board-container">
                <div id="col-headers"></div>
                <div id="row-headers"></div>
                <div id="gameBoard"></div>
            </div>
            <div id="ui-panel">
                <div id="message"></div>
                <div id="rollDisplay"></div>
                <div id="setup-choices"></div>
                <div id="action-buttons"></div>
                <div id="permanent-actions"></div>
            </div>
        </div>
        <div id="p2_panel" class="info-panel">
            <h2><div id="p2_swatch" class="color-swatch"></div> <span id="p2_header"></span></h2>
            <p>Difficulty: <b id="p2_difficulty"></b></p>
            <p>D20 Numbers: <b id="p2_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p2_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p2_captured_display" class="captured-pieces-display"></div>
        </div>
    </div>
   
    <!-- Modals -->
    <div id="dice-modal" class="modal"><div id="dice-modal-content" class="modal-content"><h3 id="dice-title">Rolling...</h3><div id="dice-container"><svg id="dice-svg" viewBox="0 0 100 100"><polygon class="face" points="50,1 95,25 95,75 50,99 5,75 5,25" /><text class="text" x="50" y="52">20</text></svg></div><div id="dice-results"></div></div></div>
    <div id="victoryModal" class="modal"><div id="victoryContent" class="modal-content"><div id="fireworks-container"></div><div id="loserAnimation" style="display: none;"><div class="loser-icon">üò≠</div></div><h2 id="victoryTitle"></h2><p id="victoryMessage"></p><div id="victoryActions"></div></div></div>
    <div id="crownChoiceModal" class="modal"><div id="crownChoiceContent" class="modal-content"><h3>You've Reached the Crown Space!</h3><p>You may Double-Stack this piece or place a Reinforcement from your reserve.</p><p>Reserve: <b id="crown-modal-reserve-count">X</b></p><div id="crownChoiceActions"></div></div></div>
    <div id="reinforceChoiceModal" class="modal"><div id="reinforceChoiceContent" class="modal-content"><h3>Choose Reinforcement Location</h3><p>Choose which side of your crown to place the new piece. The original piece will move to the opposite side of your starting row.</p><div id="reinforceChoiceActions"></div></div></div>
    <div id="quitConfirmModal" class="modal"><div class="modal-content"><h3>Quit Game?</h3><p>Are you sure you want to forfeit? This will count as a loss.</p><div id="quitConfirmActions"><button id="quitConfirmYes">Yes, I Quit</button><button id="quitConfirmNo">No, Keep Playing</button></div></div></div>

    <!-- Floating Buttons and their Modals -->
    <div id="help-button" class="floating-button">‚ùì</div>
    <div id="rulesModal" class="modal"><div class="modal-content"><span id="close-rules-button" class="modal-close-button">√ó</span><h2>Rules & Help</h2><div id="rules-content">
        <h3>1. Game Objective</h3>
        <p>Be the first player to either:</p>
        <ul>
            <li>Eliminate all of your opponent's pieces.</li>
            <li>Successfully create four crowned (double-stacked) pieces.</li>
            <li>Force your opponent into a position where they have no legal moves.</li>
        </ul>

        <h3>2. Game Components & Setup</h3>
        <h4>Grid Numbering (Row, Column)</h4>
        <ul>
            <li>The game is played on a 7x5 grid.</li>
            <li>Rows are labeled A‚ÄìE (top to bottom) and columns 1‚Äì7 (left to right).</li>
            <li>Player 2 (Bot) starts on Row A. Player 1 (You) starts on Row E.</li>
        </ul>
        <h4>Setup Process</h4>
        <ol>
            <li>Each player starts with 4 pieces on the board and 12 in reserve.</li>
            <li>Players roll a D20 to see who goes first. The winner chooses their color and whether they are <b>"Even"</b> or <b>"Odd"</b> for die rolls. The high roller also moves first.</li>
            <li>Place your 4 starting pieces anywhere on your back row (Row E for Player 1, Row A for Player 2).</li>
            <li><b>CRITICAL:</b> A player may NOT place a starting piece on their own crown space (E,4 for Player 1; A,4 for Player 2).</li>
        </ol>
        <h4>The Crown Space</h4>
        <ul>
            <li>Each player has a designated crown space, represented by a crown icon.</li>
            <li><b>FORFEIT RULE:</b> A player may NOT occupy their own crown space at any time. Moving onto your own crown space results in an automatic forfeit of the game.</li>
        </ul>

        <h3>3. Piece Status & Management</h3>
        <h4>Crowning Pieces</h4>
        <ul>
            <li>When a regular piece reaches the opponent's crown space, you get a choice (if you have reserve pieces):
                <ol>
                    <li><b>Double-Stack:</b> Take a piece from your reserve and place it on top, creating a "Crowned" piece. This uses one reserve piece.</li>
                    <li><b>Reinforce:</b> This is a two-part move.
                        <ol style="margin-top: 5px;">
                            <li>First, you place a new piece from your reserve onto an empty space to the left or right of your <b>OWN</b> crown space.</li>
                            <li>Second, the piece that just reached the opponent's crown space is immediately moved back to your starting row. It is placed on the opposite side of your crown from where you placed the new piece.</li>
                            <li><b>Bumping:</b> If a target space for either piece is occupied, it will be placed in the next available empty space on that row, moving outwards from the crown.</li>
                            <li>This option is only available if there are valid empty spots for <b>both</b> the new piece and the relocated original piece.</li>
                        </ol>
                    </li>
                </ol>
            </li>
            <li>A piece can only be double-stacked once.</li>
        </ul>
        <h4>Captured Pieces</h4>
        <ul>
            <li>Captured pieces are permanently removed from play but are kept on the side as trophies for the capturing player.</li>
        </ul>

        <h3>4. Movement & Attacks</h3>
        <h4>Basic Movement</h4>
        <ul>
            <li>Pieces move one square at a time, horizontally or vertically (forwards or backwards).</li>
        </ul>
        <h4>Basic Attack</h4>
        <ul>
            <li>Pieces attack by jumping <b>diagonally</b> over an opponent's piece to an empty square. The jumped piece is captured.</li>
        </ul>
        <h4>Chain Jump ‚ÄúDouble-Stack Attack‚Äù</h4>
        <ul>
            <li>Can only be performed by a <b>crowned</b> piece.</li>
            <li>This attack allows a crowned piece to jump over <b>two</b> separate opponent pieces in a sequence. You must declare the attack before rolling.</li>
            <li>The attack consists of two separate jumps. The dice roll for <b>each jump</b> is determined by its target:
                <ul>
                    <li>Jumping a single piece: Attacker rolls <b>1d20</b>. A successful roll (matching your Even/Odd type) captures the piece.</li>
                    <li>Jumping a crowned piece: This is a "Best of 7" contest (<b>7d20</b>). 4+ successes are needed to **un-crown** the defending piece, which remains on the board.</li>
                </ul>
            </li>
            <li>If any roll in the sequence fails, the entire attack ends immediately, and your turn is over.</li>
            <li>After both jumps are successful:
                <ul>
                    <li>The original attacking piece "disassembles". It becomes a regular (uncrowned) piece and lands on the empty square after the <b>first</b> opponent.</li>
                    <li>A second regular piece is created and lands on the empty square after the <b>second</b> opponent.</li>
                    <li>The two pieces are now separate units.</li>
                </ul>
            </li>
        </ul>

        <h3>5. Die Roll for Attack & Defense</h3>
        <h4>Attacking a Single Piece</h4>
        <ul>
            <li>The attacker rolls <b>1d20</b>. If the roll matches their type (Even/Odd), the attack succeeds.</li>
        </ul>
        <h4>Attacking a Crowned Piece (with a Single Piece)</h4>
        <ul>
            <li>The attacker rolls <b>3d20</b>. Two or more successful rolls are needed to un-crown the defender, reverting it to a single piece.</li>
        </ul>
        <h4>Attacking a Crowned Piece (with a Crowned Piece)</h4>
        <ul>
            <li>This is a "Best of 7" contest. The attacker rolls <b>7d20</b>.</li>
            <li>If the attacker gets <b>4+</b> successes (matching their type), the defender is uncrowned.</li>
            <li>If the defender's number is rolled <b>4+</b> times during the attacker's rolls, the <b>ATTACKER</b> is uncrowned instead.</li>
        </ul>
    </div></div></div>
    <div id="ai-button" class="floating-button">ü§ñ</div>
    <div id="aiModal" class="modal"><div class="modal-content"><span id="close-ai-button" class="modal-close-button">√ó</span><h2>AI Assistant</h2><div id="ai-chat-display"></div></div></div>

    <script>
        const gameBoardElement = document.getElementById('gameBoard');
        const colHeadersElement = document.getElementById('col-headers');
        const rowHeadersElement = document.getElementById('row-headers');
        const messageElement = document.getElementById('message');
        const rollDisplayElement = document.getElementById('rollDisplay');
        const actionButtonsElement = document.getElementById('action-buttons');
        const permanentActionsContainer = document.getElementById('permanent-actions');
        const setupChoicesElement = document.getElementById('setup-choices');
        let gameState = {};

        const getEl = (id) => document.getElementById(id);
        const rollD20 = () => Math.floor(Math.random() * 20) + 1;
        const getPiece = (id, gState = gameState) => gState.pieces.find(p => p.id === id);
        const getPieceAt = (r, c, gState = gameState) => {
            if (isOutOfBounds(r,c, gState)) return null;
            const pieceId = gState.board[r][c];
            return pieceId ? gState.pieces.find(p => p.id === pieceId) : null;
        };
        const isOutOfBounds = (r, c, gState = gameState) => r < 0 || r >= gState.boardSize.rows || c < 0 || c >= gState.boardSize.cols;
       
        const formatCoords = (r, c) => `(${{0:'A', 1:'B', 2:'C', 3:'D', 4:'E'}[r]}, ${c + 1})`;

        function isOwnCrownSpace(player, r, c) {
            const ownCrown = (player === 'p1') ? gameState.crownSpaces.p1 : gameState.crownSpaces.p2;
            return ownCrown.row === r && ownCrown.col === c;
        }

        function movePieceOnBoard(piece, newR, newC) {
            if (!piece) return;
            if (isOwnCrownSpace(piece.owner, newR, newC)) {
                const winner = piece.owner === 'p1' ? 'p2' : 'p1';
                const loserName = piece.owner === 'p1' ? 'You' : 'The Bot';
                setWinner(winner, `${loserName} moved onto their own crown space and forfeited the game!`);
                return;
            }
            const oldPos = piece.position;
            if(oldPos && gameState.board[oldPos.r] && gameState.board[oldPos.r][oldPos.c] === piece.id) {
                 gameState.board[oldPos.r][oldPos.c] = null;
            }
            gameState.board[newR][newC] = piece.id;
            piece.position = { r: newR, c: newC };
        }

        function render() {
            const p1Color = gameState.players.p1.color || 'transparent';
            const p2Color = gameState.players.p2.color || 'transparent';
            document.documentElement.style.setProperty('--p1-color', p1Color);
            document.documentElement.style.setProperty('--p2-color', p2Color);
            getEl('p1_swatch').style.backgroundColor = p1Color;
            getEl('p2_swatch').style.backgroundColor = p2Color;
            const p1Panel = getEl('p1_panel');
            const p2Panel = getEl('p2_panel');
            p1Panel.classList.toggle('active-turn-panel', gameState.turn === 'p1');
            p2Panel.classList.toggle('active-turn-panel', gameState.turn === 'p2');
            getEl('p1_header').textContent = `Player 1`;
            getEl('p2_header').textContent = `Player 2 (Bot)`;
           
            const difficulty = gameState.isHardMode ? 'Hard' : 'Normal';
            getEl('p1_difficulty').textContent = gameState.isHardMode === null ? 'N/A' : difficulty;
            getEl('p2_difficulty').textContent = gameState.isHardMode === null ? 'N/A' : difficulty;

            getEl('p1_die_type').textContent = gameState.players.p1.dieType ? gameState.players.p1.dieType.charAt(0).toUpperCase() + gameState.players.p1.dieType.slice(1) : 'N/A';
            getEl('p2_die_type').textContent = gameState.players.p2.dieType ? gameState.players.p2.dieType.charAt(0).toUpperCase() + gameState.players.p2.dieType.slice(1) : 'N/A';
            getEl('p1_reserve').textContent = gameState.players.p1.piecesInReserve;
            getEl('p2_reserve').textContent = gameState.players.p2.piecesInReserve;
            const p1CapturedContainer = getEl('p1_captured_display');
p1CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p1.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p2Color;
                p1CapturedContainer.appendChild(capturedEl);
            }
            const p2CapturedContainer = getEl('p2_captured_display');
            p2CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p2.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p1Color;
                p2CapturedContainer.appendChild(capturedEl);
            }
            messageElement.textContent = gameState.message;
            rollDisplayElement.textContent = gameState.rollMessage || '';
            gameBoardElement.innerHTML = '';
           
            colHeadersElement.innerHTML = '';
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                const label = document.createElement('div');
                label.className = 'grid-label';
                label.textContent = c + 1;
                colHeadersElement.appendChild(label);
            }
            rowHeadersElement.innerHTML = '';
            const rowLabels = ['A', 'B', 'C', 'D', 'E'];
            for (let r = 0; r < gameState.boardSize.rows; r++) {
                const label = document.createElement('div');
                label.className = 'grid-label';
                label.textContent = rowLabels[r];
                rowHeadersElement.appendChild(label);
            }

            for (let r = 0; r < gameState.boardSize.rows; r++) {
                for (let c = 0; c < gameState.boardSize.cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                   
                    if ((r + c) % 2 === 0) {
                        cell.style.backgroundColor = 'var(--cell-bg-light)';
                    } else {
                        cell.style.backgroundColor = 'var(--cell-bg-dark)';
                    }

                    if (r === gameState.crownSpaces.p1.row && c === gameState.crownSpaces.p1.col) cell.classList.add('player1-crown-spot');
                    if (r === gameState.crownSpaces.p2.row && c === gameState.crownSpaces.p2.col) cell.classList.add('player2-crown-spot');
                    if (gameState.highlightedMoves.some(m => m.r === r && m.c === c)) cell.classList.add('highlight-move');
                    if (gameState.highlightedAttacks.some(a => a.landing.r === r && a.landing.c === c)) cell.classList.add('highlight-attack');
                    if (gameState.highlightedDoubleStackAttacks.some(p => p.r === r && p.c === c)) cell.classList.add('highlight-double-stack');
                    if (gameState.highlightedPendingAttack && gameState.highlightedPendingAttack.r === r && gameState.highlightedPendingAttack.c === c) cell.classList.add('highlight-pending-attack');
                    if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) cell.classList.add('highlight-placement');
                    const piece = getPieceAt(r, c);
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.classList.add('player-piece', piece.owner === 'p1' ? 'p1-piece' : 'p2-piece');
                        pieceEl.dataset.pieceId = piece.id;
                        if (piece.isCrowned) {
                            pieceEl.classList.add('crowned');
                            const crownIcon = document.createElement('div');
                            crownIcon.classList.add('crown-icon');
                            crownIcon.textContent = 'üëë';
                            pieceEl.appendChild(crownIcon);
                        }
                        if (piece.id === gameState.selectedPieceId) pieceEl.classList.add('selected');
                        cell.appendChild(pieceEl);
                    }
                    gameBoardElement.appendChild(cell);
                }
            }
            setupChoicesElement.innerHTML = '';
            if (gameState.gamePhase === 'SETUP_CHOICE') {
                const colors = ['#0096C7', '#FF9F1C'];
                if (!gameState.players.p1.color) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose Color:</b>';
                    colors.forEach(color => {
                        const button = document.createElement('button');
                        button.textContent = color === '#0096C7' ? 'Blue' : 'Orange';
                        button.onclick = () => chooseColor(color);
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
                if (!gameState.players.p1.dieType) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose D20 Numbers:</b>';
                    ['Even', 'Odd'].forEach(type => {
                        const button = document.createElement('button');
                        button.textContent = type;
                        button.onclick = () => chooseDieType(type.toLowerCase());
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
            }
            actionButtonsElement.innerHTML = '';
            gameState.actions.forEach(action => {
                const button = document.createElement('button');
                button.textContent = action.text;
                button.onclick = action.onClick;
                button.disabled = action.disabled || false;
                actionButtonsElement.appendChild(button);
            });
            permanentActionsContainer.innerHTML = '';
            if (gameState.gamePhase === 'PLAYING' && gameState.turn === 'p1') {
                 const quitButton = document.createElement('button');
                 quitButton.id = 'quitButton';
                 quitButton.textContent = "Quit Game";
                 quitButton.onclick = () => getEl('quitConfirmModal').classList.add('visible');
                 permanentActionsContainer.appendChild(quitButton);
            }
        }
       
        function handleBoardClick(event) {
            if (gameState.gamePhase === 'GAME_OVER' || gameState.pendingMultiRoll) return;
            const pieceEl = event.target.closest('[data-piece-id]');
            const cellEl = event.target.closest('[data-row]');
            if (gameState.gamePhase === 'PLAYING' && gameState.turn === 'p1') {
                if (pieceEl) {
                    const pieceId = parseInt(pieceEl.dataset.pieceId);
                    const piece = getPiece(pieceId);
                    if (piece.owner === 'p1') selectPiece(pieceId);
                } else if (cellEl && gameState.selectedPieceId !== null) {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    declareMoveOrAttack(r, c);
                }
            } else if (gameState.gamePhase === 'SETUP_PLACEMENT') {
                if (cellEl && gameState.placingPlayer === 'p1') {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    placeStartingPiece(r, c);
                }
            }
        }

        function initializeGame() {
            document.body.classList.remove('game-over');
            getEl('loserAnimation').style.display = 'none';
            getEl('loserAnimation').innerHTML = '<div class="loser-icon">üò≠</div>';
            getEl('fireworks-container').style.display = 'none';
            getEl('fireworks-container').innerHTML = '';
           
            gameState = {
                boardSize: { rows: 5, cols: 7 },
                board: Array(5).fill(0).map(() => Array(7).fill(null)),
                pieces: [],
                players: {
                    p1: { id: 'p1', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 },
                    p2: { id: 'p2', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 }
                },
                crownSpaces: { p1: { row: 4, col: 3 }, p2: { row: 0, col: 3 } },
                turn: null, gamePhase: 'SETUP_DIFFICULTY', winner: null,
                isHardMode: null,
                message: "Choose your difficulty.",
                rollMessage: '', selectedPieceId: null,
                highlightedMoves: [], highlightedAttacks: [], highlightedPlacements: [], highlightedPendingAttack: null, highlightedDoubleStackAttacks: [],
                pendingAttack: null, pendingDoubleStackAttack: null, pieceToCrownId: null,
                pendingMultiRoll: null,
                actions: [
                    { text: 'Normal Mode', onClick: () => setDifficulty(false) },
                    { text: 'Hard Mode', onClick: () => setDifficulty(true) },
                ]
            };
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('visible'));
            render();
        }

        function setDifficulty(isHard) {
            gameState.isHardMode = isHard;
            gameState.gamePhase = 'SETUP_D20_ROLL';
            gameState.message = "Let's begin! Roll to start the game.";
            gameState.actions = [{ text: 'Roll to Start Game', onClick: setupRollOff }];
            render();
        }
       
        async function setupRollOff() {
            gameState.actions = [];
            render();
            const p1Roll = await showDiceRoll("Player 1 Rolling...");
            const p2Roll = await showDiceRoll("Bot Rolling...");
            gameState.rollMessage = `Player 1 rolled a ${p1Roll}. Bot rolled a ${p2Roll}.`;
            let firstPlayer;
            if (p1Roll > p2Roll) {
                firstPlayer = 'p1';
                gameState.gamePhase = 'SETUP_CHOICE';
                gameState.message = 'You rolled higher! You will move first. Choose your color and D20 numbers.';
            } else if (p2Roll > p1Roll) {
                firstPlayer = 'p2';
                const botColor = Math.random() < 0.5 ? '#0096C7' : '#FF9F1C';
                const botDieType = Math.random() < 0.5 ? 'even' : 'odd';
                gameState.players.p2.color = botColor;
                gameState.players.p2.dieType = botDieType;
                gameState.players.p1.color = botColor === '#0096C7' ? '#FF9F1C' : '#0096C7';
                gameState.players.p1.dieType = botDieType === 'even' ? 'odd' : 'even';
                gameState.message = `Bot rolled higher and will move first. Bot has chosen its settings.`;
                startPlacementPhase(firstPlayer);
            } else {
                gameState.message = "It's a tie! Roll again.";
                gameState.actions = [{ text: 'Roll to Start Game', onClick: setupRollOff }];
            }
            gameState.turn = firstPlayer;
            render();
        }

        function chooseColor(color) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.color) return;
            gameState.players.p1.color = color;
            gameState.players.p2.color = color === '#0096C7' ? '#FF9F1C' : '#0096C7';
            checkSetupChoices();
        }
        function chooseDieType(type) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.dieType) return;
            gameState.players.p1.dieType = type;
            gameState.players.p2.dieType = type === 'even' ? 'odd' : 'even';
            checkSetupChoices();
        }
        function checkSetupChoices() {
            if (gameState.players.p1.color && gameState.players.p1.dieType) {
                startPlacementPhase(gameState.turn);
            }
            render();
        }

        function startPlacementPhase(firstPlayer) {
            gameState.gamePhase = 'SETUP_PLACEMENT';
            gameState.placingPlayer = firstPlayer;
            gameState.piecesToPlace = 4;
            gameState.actions = [];
            if (firstPlayer === 'p2') {
                placeBotStartingPieces();
                gameState.placingPlayer = 'p1';
                gameState.message = "Bot has placed its pieces. Now, place your 4 pieces on your starting row (Row E).";
            } else {
                gameState.message = 'Your turn to place 4 pieces on your starting row (Row E).';
            }
            highlightPlacementSpots();
            render();
        }
       
        function highlightPlacementSpots() {
            gameState.highlightedPlacements = [];
            const player = gameState.placingPlayer;
            const startRow = player === 'p1' ? gameState.boardSize.rows - 1 : 0;
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                if (!isOwnCrownSpace(player, startRow, c) && gameState.board[startRow][c] === null) {
                    gameState.highlightedPlacements.push({ r: startRow, c });
                }
            }
        }
       
        function placeStartingPiece(r, c) {
            if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) {
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p1', isCrowned: false, position: { r, c } });
                gameState.board[r][c] = newId;
                gameState.piecesToPlace--;
                gameState.message = `Placed piece. ${gameState.piecesToPlace} remaining.`;
                if (gameState.piecesToPlace === 0) {
                    if (gameState.pieces.filter(p => p.owner === 'p2').length === 0) { placeBotStartingPieces(); }
                    setTimeout(startGame, 500);
                }
                highlightPlacementSpots();
                render();
            }
        }
       
        function placeBotStartingPieces() {
            const startRow = 0;
            const validCols = [];
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                 if (!isOwnCrownSpace('p2', startRow, c)) {
                    validCols.push(c);
                }
            }
            let placed = 0;
            while (placed < 4 && validCols.length > 0) {
                const randIndex = Math.floor(Math.random() * validCols.length);
                const c = validCols.splice(randIndex, 1)[0];
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p2', isCrowned: false, position: { r: startRow, c } });
                gameState.board[startRow][c] = newId;
                placed++;
            }
        }

        function startGame() {
            gameState.gamePhase = 'PLAYING';
            gameState.highlightedPlacements = [];
            if (gameState.turn === 'p2') {
                gameState.message = `Bot moves first.`;
                const delay = gameState.isHardMode ? 500 : 1000;
                setTimeout(botTurn, delay);
            } else {
                gameState.message = `You move first. Select a piece.`;
            }
            gameState.actions = [];
            render();
        }

        function selectPiece(pieceId) {
            if (gameState.pendingDoubleStackAttack || gameState.gamePhase !== 'PLAYING') return;
            if (gameState.selectedPieceId === pieceId) {
                gameState.selectedPieceId = null;
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
                gameState.actions = [];
            } else {
                gameState.selectedPieceId = pieceId;
                const piece = getPiece(pieceId);
                const {r, c} = piece.position;
                const opponentCrownSpace = (piece.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
               
                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                gameState.highlightedMoves = moves.filter(m => {
                    const isOpponentCrown = (m.r === opponentCrownSpace.row && m.c === opponentCrownSpace.col);
                    if (piece.isCrowned && isOpponentCrown) return false;
                    return !isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace(piece.owner, m.r, m.c);
                });
               
                const attackDirs = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
                let hasDoubleStackAttack = false;

                for (const dir of attackDirs) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                   
                    const isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) && !getPieceAt(landingPos.r, landingPos.c) && !isOwnCrownSpace(piece.owner, landingPos.r, landingPos.c);

                    if (targetPiece && targetPiece.owner !== piece.owner && isValidLanding) {
                        gameState.highlightedAttacks.push({ type: 'single', target: targetPos, landing: landingPos });
                    }
                }

                if (piece.isCrowned) {
                    for (const dir1 of attackDirs) {
                        const opponent1Pos = { r: r + dir1.dr, c: c + dir1.dc };
                        const landing1Pos = { r: r + dir1.dr * 2, c: c + dir1.dc * 2 };
                        const opponent1 = getPieceAt(opponent1Pos.r, opponent1Pos.c);
                       
                        const isOpponentCrown1 = (landing1Pos.r === opponentCrownSpace.row && landing1Pos.c === opponentCrownSpace.col);
                        const isValidLanding1 = !isOutOfBounds(landing1Pos.r, landing1Pos.c) && !getPieceAt(landing1Pos.r, landing1Pos.c) && !isOwnCrownSpace(piece.owner, landing1Pos.r, landing1Pos.c) && !isOpponentCrown1;

                        if (opponent1 && opponent1.owner !== piece.owner && isValidLanding1) {
                            for (const dir2 of attackDirs) {
                                const opponent2Pos = { r: landing1Pos.r + dir2.dr, c: landing1Pos.c + dir2.dc };
                                const landing2Pos = { r: landing1Pos.r + dir2.dr * 2, c: landing1Pos.c + dir2.dc * 2 };
                                const opponent2 = getPieceAt(opponent2Pos.r, opponent2Pos.c);

                                const isOpponentCrown2 = (landing2Pos.r === opponentCrownSpace.row && landing2Pos.c === opponentCrownSpace.col);
                                const isValidLanding2 = !isOutOfBounds(landing2Pos.r, landing2Pos.c) && !getPieceAt(landing2Pos.r, landing2Pos.c) && !isOwnCrownSpace(piece.owner, landing2Pos.r, landing2Pos.c) && !isOpponentCrown2;

                                if (opponent2 && opponent2.owner !== piece.owner && opponent2.id !== opponent1.id && isValidLanding2) {
                                    hasDoubleStackAttack = true;
                                    gameState.highlightedAttacks.push({
                                        type: 'double-stack',
                                        landing: landing2Pos,
                                        path: { opponent1: opponent1Pos, landing1: landing1Pos, opponent2: opponent2Pos }
                                    });
                                    gameState.highlightedDoubleStackAttacks.push(landing2Pos);
                                }
                            }
                        }
                    }
                }
               
                gameState.actions = [];
                if (hasDoubleStackAttack) {
                     gameState.actions.push({ text: 'Declare Double-Stack Attack', onClick: () => declareDoubleStackAttack() });
                }
            }
            render();
        }
       
        function declareDoubleStackAttack() {
            if (!gameState.selectedPieceId) return;
            const piece = getPiece(gameState.selectedPieceId);
            if (!piece || !piece.isCrowned) return;

            gameState.pendingDoubleStackAttack = { pieceId: gameState.selectedPieceId };
            gameState.message = "Double-Stack Attack declared! Click a purple square to perform the multi-jump.";
           
            gameState.highlightedAttacks = gameState.highlightedAttacks.filter(a => a.type === 'double-stack');
            gameState.highlightedMoves = [];
           
            gameState.actions = [{ text: "Cancel Attack", onClick: cancelAttack }];
            render();
        }

        function declareMoveOrAttack(r, c) {
            const attack = gameState.highlightedAttacks.find(a => a.landing.r === r && a.landing.c === c);
            const move = gameState.highlightedMoves.find(m => m.r === r && m.c === c);
           
            if (move && !gameState.pendingDoubleStackAttack) {
                executeMove(gameState.selectedPieceId, move.r, move.c);
                return;
            }

            if (attack) {
                gameState.highlightedPendingAttack = { r: attack.landing.r, c: attack.landing.c };
               
                if (attack.type === 'double-stack') {
                    if (!gameState.pendingDoubleStackAttack) {
                        gameState.message = "You must declare a Double-Stack Attack first using the button.";
                        render();
                        return;
                    }
                    gameState.pendingDoubleStackAttack.path = attack.path;
                    gameState.pendingDoubleStackAttack.landingPos = attack.landing;
                    gameState.message = "Roll to start your Double-Stack Attack!";
                } else {
                    gameState.pendingAttack = { pieceId: gameState.selectedPieceId, targetPos: attack.target, landingPos: attack.landing };
                    gameState.message = "You have declared an attack!";
                }
               
                gameState.actions = [
                    { text: "Roll to Attack", onClick: startAttack },
                    { text: "Cancel Attack", onClick: cancelAttack }
                ];
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
            }
            render();
        }
       
        function cancelAttack() {
            const pieceId = gameState.selectedPieceId;
            gameState.pendingAttack = null;
            gameState.pendingDoubleStackAttack = null;
            gameState.highlightedPendingAttack = null;
            gameState.message = "Attack canceled. Select a move or another attack.";
            selectPiece(pieceId);
        }

        function executeMove(pieceId, r, c) {
            const piece = getPiece(pieceId);
            movePieceOnBoard(piece, r, c);
            if(gameState.winner) return;

            const oppCrown = gameState.crownSpaces[piece.owner === 'p1' ? 'p2' : 'p1'];
            if (r === oppCrown.row && c === oppCrown.col) {
                enterCrowningPhase(pieceId);
            } else {
                endTurn();
            }
        }
       
        async function startAttack() {
            gameState.actions = [];
            render();

            if (gameState.pendingDoubleStackAttack) {
                startDoubleStackSequence();
                return;
            }

            const attackData = gameState.pendingAttack;
            if (!attackData) return;

            const attacker = getPiece(attackData.pieceId);
            const defender = getPieceAt(attackData.targetPos.r, attackData.targetPos.c);
           
            let numRolls = 1;
            if (attacker.isCrowned && defender?.isCrowned) numRolls = 7;
            else if (!attacker.isCrowned && defender?.isCrowned) numRolls = 3;

            if (numRolls === 1) {
                const roll = await showDiceRoll(`${attacker.owner === 'p1' ? 'Player 1' : 'Bot'} Attacking...`);
                const isSuccess = (gameState.players[attacker.owner].dieType === 'even' && roll % 2 === 0) || (gameState.players[attacker.owner].dieType === 'odd' && roll % 2 !== 0);
               
                if(isSuccess) {
                    gameState.message = "Attack successful!";
                    gameState.players[attacker.owner].capturedOpponentPieces++;
                    gameState.board[attackData.targetPos.r][attackData.targetPos.c] = null;
                    gameState.pieces = gameState.pieces.filter(p => p.id !== defender.id);
                    movePieceOnBoard(attacker, attackData.landingPos.r, attackData.landingPos.c);
                    if(gameState.winner) return;
                    const oppCrown = (attacker.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
                    if (attackData.landingPos.r === oppCrown.row && attackData.landingPos.c === oppCrown.col) {
                        enterCrowningPhase(attacker.id);
                    } else {
                        setTimeout(endTurn, 2000);
                    }
                } else {
                    gameState.message = "Attack failed!";
                    setTimeout(endTurn, 2000);
                }
            } else {
                gameState.pendingMultiRoll = { attackData, rollsNeeded: numRolls, rollsMade: 0, successes: 0, defenderSuccesses: 0, onComplete: resolveMultiRollAttack };
                gameState.message = `Attack initiated! Need to roll ${numRolls} dice.`;
                gameState.rollMessage = `Successes: 0 / ${numRolls} rolls made`;
                if(gameState.turn === 'p1') {
                    gameState.actions = [{text: `Roll Die (1 of ${numRolls})`, onClick: executeSingleRoll}];
                } else { setTimeout(executeSingleRoll, 1000); }
                render();
            }
        }
       
        async function executeSingleRoll() {
            if (!gameState.pendingMultiRoll) return;

            const multiRoll = gameState.pendingMultiRoll;
            gameState.actions = [];
            render();
           
            const attackerOwner = multiRoll.attackData.pieceId ? getPiece(multiRoll.attackData.pieceId).owner : gameState.turn;
            const defenderOwner = attackerOwner === 'p1' ? 'p2' : 'p1';
            const roll = await showDiceRoll(`${attackerOwner === 'p1' ? 'Player 1' : 'Bot'} rolling...`);
           
            multiRoll.rollsMade++;
            const isAttackerSuccess = (gameState.players[attackerOwner].dieType === 'even' && roll % 2 === 0) || (gameState.players[attackerOwner].dieType === 'odd' && roll % 2 !== 0);
            const isDefenderSuccess = (gameState.players[defenderOwner].dieType === 'even' && roll % 2 === 0) || (gameState.players[defenderOwner].dieType === 'odd' && roll % 2 !== 0);

            if (isAttackerSuccess) multiRoll.successes++;
            if (multiRoll.rollsNeeded === 7 && isDefenderSuccess) multiRoll.defenderSuccesses++;

            gameState.message = `Roll ${multiRoll.rollsMade} of ${multiRoll.rollsNeeded} was a ${roll}.`;
            let successMsg = `Attacker Successes: ${multiRoll.successes}`;
            if (multiRoll.rollsNeeded === 7) successMsg += ` | Defender Successes: ${multiRoll.defenderSuccesses}`;
            gameState.rollMessage = successMsg;

            if (multiRoll.rollsMade >= multiRoll.rollsNeeded) {
                const onCompleteCallback = gameState.pendingMultiRoll.onComplete;
                if(onCompleteCallback) {
                    onCompleteCallback();
                }
            } else {
                if (gameState.turn === 'p1') {
                    gameState.actions = [{text: `Roll Die (${multiRoll.rollsMade + 1} of ${multiRoll.rollsNeeded})`, onClick: executeSingleRoll}];
                } else {
                    setTimeout(executeSingleRoll, 1500);
                }
            }
            render();
        }

        function resolveMultiRollAttack() {
            const { attackData, rollsNeeded, successes, defenderSuccesses } = gameState.pendingMultiRoll;
            const attacker = getPiece(attackData.pieceId);
            const defender = getPieceAt(attackData.targetPos.r, attackData.targetPos.c);
            let message = "";

            if (rollsNeeded === 3) { // Single vs Crowned
                if (successes >= 2) {
                    defender.isCrowned = false;
                    message = `Attack successful! (${successes}/3) Defender is uncrowned.`;
                } else {
                    message = `Attack failed! (${successes}/3) Defender is safe.`;
                }
            } else if (rollsNeeded === 7) { // Crowned vs Crowned
                if (successes >= 4) {
                    defender.isCrowned = false;
                    message = `Crowned attack successful! (${successes} vs ${defenderSuccesses}) Defender is uncrowned.`;
                } else if (defenderSuccesses >= 4) {
                    attacker.isCrowned = false;
                    message = `Crowned attack FAILED! (${successes} vs ${defenderSuccesses}) Your piece is uncrowned.`;
                } else {
                    message = `Roll-off is a draw (${successes} to ${defenderSuccesses}). No pieces are changed.`;
                }
            }
            gameState.message = message;
            setTimeout(endTurn, 2500);
        }

        async function startDoubleStackSequence() {
            gameState.pendingDoubleStackAttack.stage = 1;
            executeNextDoubleStackJump();
        }

        async function executeNextDoubleStackJump() {
            const { pieceId, path, stage } = gameState.pendingDoubleStackAttack;
            const attacker = getPiece(pieceId);
            const defenderPos = (stage === 1) ? path.opponent1 : path.opponent2;
            const defender = getPieceAt(defenderPos.r, defenderPos.c);

            if (!defender) {
                gameState.message = "Error: Target piece for jump not found.";
                setTimeout(endTurn, 2000);
                return;
            }

            gameState.message = `Double-Stack Attack: Stage ${stage} of 2.`;
            gameState.rollMessage = `Jumping piece at ${formatCoords(defenderPos.r, defenderPos.c)}.`;
            render();

            const isDefenderCrowned = defender.isCrowned;
            const numRolls = isDefenderCrowned ? 7 : 1;
           
            if (numRolls === 1) {
                const roll = await showDiceRoll(`${attacker.owner === 'p1' ? 'Player 1' : 'Bot'} attacking...`);
                const isSuccess = (gameState.players[attacker.owner].dieType === 'even' && roll % 2 === 0) || (gameState.players[attacker.owner].dieType === 'odd' && roll % 2 !== 0);
                resolveCurrentDoubleStackJump(isSuccess);
            } else { // numRolls === 7
                gameState.pendingMultiRoll = {
                    attackData: { pieceId: attacker.id, targetPos: defenderPos },
                    rollsNeeded: 7,
                    rollsMade: 0,
                    successes: 0,
                    defenderSuccesses: 0,
                    onComplete: () => {
                        const { successes, defenderSuccesses } = gameState.pendingMultiRoll;
                        const wasSuccess = successes >= 4 && defenderSuccesses < 4;
                        resolveCurrentDoubleStackJump(wasSuccess);
                    }
                };
                gameState.message = `Double-Stack Attack (Stage ${stage}): Crowned target! Best of 7 rolls.`;
                if(gameState.turn === 'p1') {
                    gameState.actions = [{text: `Roll Die (1 of 7)`, onClick: executeSingleRoll}];
                } else { setTimeout(executeSingleRoll, 1000); }
                render();
            }
        }

        function resolveCurrentDoubleStackJump(wasSuccess) {
            const { pieceId, path, stage } = gameState.pendingDoubleStackAttack;
            if (!wasSuccess) {
                gameState.message = `Double-Stack Attack failed at Stage ${stage}.`;
                gameState.rollMessage = "The attack ends.";
                setTimeout(endTurn, 2500);
                return;
            }

            const attacker = getPiece(pieceId);
            const defenderPos = (stage === 1) ? path.opponent1 : path.opponent2;
            const landingPos = (stage === 1) ? path.landing1 : path.landingPos;
            const defender = getPieceAt(defenderPos.r, defenderPos.c);
           
            if (defender.isCrowned) {
                defender.isCrowned = false;
                gameState.message = `Jump ${stage} successful! Piece at ${formatCoords(defenderPos.r, defenderPos.c)} was uncrowned.`;
            } else {
                gameState.board[defenderPos.r][defenderPos.c] = null;
                gameState.pieces = gameState.pieces.filter(p => p.id !== defender.id);
                gameState.players[attacker.owner].capturedOpponentPieces++;
                gameState.message = `Jump ${stage} successful! Piece at ${formatCoords(defenderPos.r, defenderPos.c)} captured.`;
            }

            if (stage === 1) {
                movePieceOnBoard(attacker, landingPos.r, landingPos.c);
                if (gameState.winner) return;
                gameState.pendingDoubleStackAttack.stage = 2;
                render();
                setTimeout(executeNextDoubleStackJump, 1500);
            } else { // Stage 2 success - final resolution
                attacker.isCrowned = false;
               
                const newId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
                const newPiece = { id: newId, owner: attacker.owner, isCrowned: false, position: null };
                gameState.pieces.push(newPiece);
                movePieceOnBoard(newPiece, path.landingPos.r, path.landingPos.c);
                if (gameState.winner) return;

                gameState.message = "Double-Stack Attack complete! The piece split and handled two opponents.";
               
                const oppCrown = (attacker.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
                if (path.landing1.r === oppCrown.row && path.landing1.c === oppCrown.col) {
                    enterCrowningPhase(attacker.id);
                } else if (newPiece.position.r === oppCrown.row && newPiece.position.c === oppCrown.col) {
                    enterCrowningPhase(newPiece.id);
                } else {
                    setTimeout(endTurn, 2500);
                }
            }
        }
       
        function promptReinforceChoice() {
            getEl('crownChoiceModal').classList.remove('visible');
            const reinforceModal = getEl('reinforceChoiceModal');
            const actionsContainer = getEl('reinforceChoiceActions');
            actionsContainer.innerHTML = '';

            const piece = getPiece(gameState.pieceToCrownId);
            if (!piece) { endTurn(); return; }
            const player = piece.owner;
            const ownCrownSpace = gameState.crownSpaces[player];
            const startRow = ownCrownSpace.row;

            const newPieceSpotLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
            const relocatedPieceSpotRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
            const canPlaceLeft = newPieceSpotLeft && relocatedPieceSpotRight;

            const newPieceSpotRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
            const relocatedPieceSpotLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
            const canPlaceRight = newPieceSpotRight && relocatedPieceSpotLeft;
           
            if (canPlaceLeft) {
                const leftButton = document.createElement('button');
                leftButton.textContent = "Place Left";
                leftButton.onclick = () => {
                    reinforceModal.classList.remove('visible');
                    resolveCrowning('reinforce', { newPiecePos: newPieceSpotLeft, relocatedPiecePos: relocatedPieceSpotRight });
                };
                actionsContainer.appendChild(leftButton);
            }
            if (canPlaceRight) {
                const rightButton = document.createElement('button');
                rightButton.textContent = "Place Right";
                rightButton.onclick = () => {
                    reinforceModal.classList.remove('visible');
                    resolveCrowning('reinforce', { newPiecePos: newPieceSpotRight, relocatedPiecePos: relocatedPieceSpotLeft });
                };
                actionsContainer.appendChild(rightButton);
            }
            if (!canPlaceLeft && !canPlaceRight) {
                actionsContainer.innerHTML = "<p>No available space to place a reinforcement and relocate the original piece.</p>";
                const okButton = document.createElement('button');
                okButton.textContent = "OK";
                okButton.onclick = () => { reinforceModal.classList.remove('visible'); endTurn(); };
                actionsContainer.appendChild(okButton);
            }
            reinforceModal.classList.add('visible');
        }

        function enterCrowningPhase(pieceId) {
            gameState.gamePhase = 'AWAITING_CROWNING_CHOICE';
            gameState.pieceToCrownId = pieceId;
            const piece = getPiece(pieceId);
            if (!piece || piece.isCrowned) {
                endTurn();
                return;
            }

            const player = piece.owner;
            const playerObj = gameState.players[player];
            const hasReserves = playerObj.piecesInReserve > 0;
           
            gameState.message = `${player === 'p1' ? 'You have' : 'Bot has'} reached the opponent's crown space!`;
            gameState.actions = [];
            render();

            if (player === 'p1') {
                const crownModal = getEl('crownChoiceModal');
                const actionsContainer = getEl('crownChoiceActions');
                actionsContainer.innerHTML = '';
                getEl('crown-modal-reserve-count').textContent = playerObj.piecesInReserve;
               
                const crownButton = document.createElement('button');
                crownButton.textContent = "Double-Stack";
                crownButton.onclick = () => { crownModal.classList.remove('visible'); resolveCrowning('crown'); };
                crownButton.disabled = !hasReserves;
                actionsContainer.appendChild(crownButton);

                const reinforceButton = document.createElement('button');
                reinforceButton.textContent = "Place Reinforcement";
                reinforceButton.onclick = () => promptReinforceChoice();
               
                const ownCrownSpace = gameState.crownSpaces.p1;
                const startRow = ownCrownSpace.row;
                const newPieceSpotLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
                const relocatedPieceSpotRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
                const canPlaceLeft = newPieceSpotLeft && relocatedPieceSpotRight;
                const newPieceSpotRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
                const relocatedPieceSpotLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
                const canPlaceRight = newPieceSpotRight && relocatedPieceSpotLeft;
                const canReinforce = canPlaceLeft || canPlaceRight;

                reinforceButton.disabled = !hasReserves || !canReinforce;
                actionsContainer.appendChild(reinforceButton);
               
                if (!hasReserves) {
                    const noActionInfo = document.createElement('p');
                    noActionInfo.textContent = "You have no pieces in reserve to take an action.";
                    actionsContainer.appendChild(noActionInfo);
                     setTimeout(() => { crownModal.classList.remove('visible'); resolveCrowning('none'); }, 2500);
                }
                crownModal.classList.add('visible');

            } else { // Bot's Crowning Choice
                setTimeout(() => {
                    if (!hasReserves) {
                        resolveCrowning('none');
                        return;
                    }

                    // Bot uses Minimax-like evaluation for this choice too
                    let bestChoice = 'none';
                    let bestScore = -Infinity;

                    // Evaluate crowning
                    const crownState = applyActionToState({type: 'crown', pieceId: pieceId}, 'p2', gameState);
                    const crownScore = evaluateBoardState(crownState, 'p2');
                    if (crownScore > bestScore) {
                        bestScore = crownScore;
                        bestChoice = 'crown';
                    }
                   
                    // Evaluate reinforcing
                    const ownCrownSpace = gameState.crownSpaces.p2;
                    const startRow = ownCrownSpace.row;
                    const placements = [];
                    const pLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
                    const rRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
                    if(pLeft && rRight) placements.push({ newPiecePos: pLeft, relocatedPiecePos: rRight });
                    const pRight = findNextAvailableSpot(startRow, ownCrownSpace.col + 1, 1);
                    const rLeft = findNextAvailableSpot(startRow, ownCrownSpace.col - 1, -1);
                    if(pRight && rLeft) placements.push({ newPiecePos: pRight, relocatedPiecePos: rLeft });

                    let bestReinforceData = null;
                    for (const placementData of placements) {
                        const reinforceState = applyActionToState({type: 'reinforce', pieceId: pieceId, placementData}, 'p2', gameState);
                        const reinforceScore = evaluateBoardState(reinforceState, 'p2');
                        if (reinforceScore > bestScore) {
                            bestScore = reinforceScore;
                            bestChoice = 'reinforce';
                            bestReinforceData = placementData;
                        }
                    }

                    resolveCrowning(bestChoice, bestReinforceData);

                }, 1000);
            }
        }

        function resolveCrowning(choice, placementData = null) {
            const piece = getPiece(gameState.pieceToCrownId);
            if (!piece) { endTurn(); return; }
            const player = piece.owner;
            const playerObj = gameState.players[player];

            if (choice === 'crown' && playerObj.piecesInReserve > 0) {
                piece.isCrowned = true;
                playerObj.piecesInReserve--;
                gameState.message = `${player === 'p1' ? 'Your' : "The Bot's"} piece has been Double-Stacked!`;
            } else if (choice === 'reinforce' && placementData && playerObj.piecesInReserve > 0) {
                const { newPiecePos, relocatedPiecePos } = placementData;
                const newId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
                const newPiece = { id: newId, owner: player, isCrowned: false, position: null };
                gameState.pieces.push(newPiece);
                movePieceOnBoard(newPiece, newPiecePos.r, newPiecePos.c);
                if(gameState.winner) return;
                playerObj.piecesInReserve--;

                movePieceOnBoard(piece, relocatedPiecePos.r, relocatedPiecePos.c);
                if(gameState.winner) return;

                gameState.message = `${player === 'p1' ? 'You' : "The Bot"} reinforced! A new piece was placed and the original returned.`;
            } else {
                 gameState.message = "No reserve action was taken.";
            }
            gameState.gamePhase = 'PLAYING';
            gameState.pieceToCrownId = null;
            endTurn();
        }

        function checkForWin(gState = gameState) {
            const p1Pieces = gState.pieces.filter(p => p.owner === 'p1');
            const p2Pieces = gState.pieces.filter(p => p.owner === 'p2');
           
            if (p2Pieces.length === 0) return { winner: 'p1', reason: 'You eliminated all opponent pieces!' };
            if (p1Pieces.length === 0) return { winner: 'p2', reason: 'The Bot eliminated all of your pieces!' };
           
            if (p1Pieces.filter(p => p.isCrowned).length >= 4) return { winner: 'p1', reason: 'You have 4 crowned pieces!' };
            if (p2Pieces.filter(p => p.isCrowned).length >= 4) return { winner: 'p2', reason: 'The Bot has 4 crowned pieces!' };
           
            if (gState.turn && gState.gamePhase === 'PLAYING') {
                const possibleActions = getAllPossibleActions(gState.turn, gState);
                if (possibleActions.length === 0) {
                    const loser = gState.turn;
                    const winner = loser === 'p1' ? 'p2' : 'p1';
                    const loserName = loser === 'p1' ? 'You have' : 'The Bot has';
                    return { winner: winner, reason: `${loserName} no available moves and forfeits the game!` };
                }
            }

            return null;
        }

        function setWinner(winner, message) {
            gameState.gamePhase = 'GAME_OVER';
            gameState.winner = winner;
            document.body.classList.add('game-over');
            const modal = getEl('victoryModal');
            getEl('victoryTitle').textContent = winner === 'p1' ? 'VICTORY!' : 'DEFEAT!';
            getEl('victoryMessage').textContent = message;
           
            const fireworksContainer = getEl('fireworks-container');
            const loserAnimationContainer = getEl('loserAnimation');
            fireworksContainer.innerHTML = '';

            if (winner === 'p1') {
                loserAnimationContainer.style.display = 'none';
                fireworksContainer.style.display = 'block';
                const numFireworks = 25;
                for (let i = 0; i < numFireworks; i++) {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.top = (10 + Math.random() * 80) + '%';
                    firework.style.left = (10 + Math.random() * 80) + '%';
                    firework.style.transform = `scale(${0.5 + Math.random()})`;
                    firework.style.animationDelay = (Math.random() * 2) + 's';
                    fireworksContainer.appendChild(firework);
                }
            } else {
                fireworksContainer.style.display = 'none';
                loserAnimationContainer.style.display = 'block';
                loserAnimationContainer.innerHTML = '<div class="loser-icon">üò≠</div>';
                for (let i = 0; i < 50; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'raindrop';
                    drop.style.left = Math.random() * 100 + '%';
                    drop.style.animationDelay = Math.random() * 2 + 's';
                    drop.style.animationDuration = 0.5 + Math.random() * 0.5 + 's';
                    loserAnimationContainer.appendChild(drop);
                }
            }
           
            const actions = getEl('victoryActions');
            actions.innerHTML = '';
            const button = document.createElement('button');
            button.textContent = "Play Again?";
            button.onclick = initializeGame;
            actions.appendChild(button);
            modal.classList.add('visible');
            render();
        }

        function endTurn() {
            gameState.selectedPieceId = null;
            gameState.highlightedMoves = [];
            gameState.highlightedAttacks = [];
            gameState.highlightedPendingAttack = null;
            gameState.highlightedDoubleStackAttacks = [];
            gameState.pendingAttack = null;
            gameState.pendingDoubleStackAttack = null;
            gameState.pendingMultiRoll = null;
            gameState.actions = [];
            gameState.rollMessage = '';

            let winCondition = checkForWin(gameState);
            if (winCondition) {
                setWinner(winCondition.winner, winCondition.reason);
                return;
            }

            gameState.turn = gameState.turn === 'p1' ? 'p2' : 'p1';

            // Check for trapped player at the start of their new turn
            winCondition = checkForWin(gameState);
             if (winCondition) {
                setWinner(winCondition.winner, winCondition.reason);
                return;
            }

            gameState.message = `${gameState.turn === 'p1' ? 'Your' : "Bot's"} turn to move.`;
            render();
            if (gameState.turn === 'p2' && gameState.gamePhase === 'PLAYING') {
                 const delay = gameState.isHardMode ? 500 : 1200;
                 setTimeout(botTurn, delay);
            }
        }
       
        // --- MINIMAX AI LOGIC ---

        function botTurn() {
            if(gameState.winner) return;
            const depth = gameState.isHardMode ? 4 : 2;
            gameState.message = `The Bot is thinking... (Depth: ${depth})`;
            render();

            setTimeout(() => { // Gives the UI time to update message
                const bestAction = findBestMove(gameState, depth);

                if (!bestAction) { // Should be caught by win condition, but for safety
                    endTurn();
                    return;
                }

                if (bestAction.type === 'move') {
                    executeMove(bestAction.pieceId, bestAction.r, bestAction.c);
                } else if (bestAction.type === 'attack') {
                    gameState.pendingAttack = bestAction;
                    startAttack();
                } else if (bestAction.type === 'double-stack') {
                    gameState.pendingDoubleStackAttack = { pieceId: bestAction.pieceId, path: bestAction.path, landingPos: bestAction.landingPos };
                    startAttack();
                }
            }, 100);
        }

        function findBestMove(gState, depth) {
            let bestScore = -Infinity;
            let bestActions = [];
            const possibleActions = getAllPossibleActions('p2', gState);

            for (const action of possibleActions) {
                const newState = applyActionToState(action, 'p2', gState);
                const score = minimax(newState, depth - 1, -Infinity, Infinity, false); // false because it's now player's turn
               
                if (score > bestScore) {
                    bestScore = score;
                    bestActions = [action];
                } else if (score === bestScore) {
                    bestActions.push(action);
                }
            }

            // Choose randomly among the best actions to add variability
            return bestActions[Math.floor(Math.random() * bestActions.length)];
        }

        function minimax(gState, depth, alpha, beta, isMaximizingPlayer) {
            const winInfo = checkForWin(gState);
            if (depth === 0 || winInfo) {
                return evaluateBoardState(gState, 'p2');
            }

            if (isMaximizingPlayer) { // Bot's turn
                let maxEval = -Infinity;
                const actions = getAllPossibleActions('p2', gState);
                for (const action of actions) {
                    const childState = applyActionToState(action, 'p2', gState);
                    const evaluation = minimax(childState, depth - 1, alpha, beta, false);
                    maxEval = Math.max(maxEval, evaluation);
                    alpha = Math.max(alpha, evaluation);
                    if (beta <= alpha) {
                        break; // Prune
                    }
                }
                return maxEval;
            } else { // Player's turn
                let minEval = Infinity;
                const actions = getAllPossibleActions('p1', gState);
                for (const action of actions) {
                    const childState = applyActionToState(action, 'p1', gState);
                    const evaluation = minimax(childState, depth - 1, alpha, beta, true);
                    minEval = Math.min(minEval, evaluation);
                    beta = Math.min(beta, evaluation);
                    if (beta <= alpha) {
                        break; // Prune
                    }
                }
                return minEval;
            }
        }

        // --- AI HELPER FUNCTIONS ---

        function findNextAvailableSpot(row, startCol, direction, gState = gameState) {
            let c = startCol;
            while (!isOutOfBounds(row, c, gState)) {
                if (getPieceAt(row, c, gState) === null) {
                    return { r: row, c: c };
                }
                c += direction;
            }
            return null;
        }
       
        function getAllPossibleActions(playerId, gState) {
            const allActions = [];
            const myPieces = gState.pieces.filter(p => p.owner === playerId);
            const opponentId = (playerId === 'p1') ? 'p2' : 'p1';
            const opponentCrownSpace = gState.crownSpaces[opponentId];
            const ownCrownSpace = gState.crownSpaces[playerId];

            for (const piece of myPieces) {
                const {r, c} = piece.position;

                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                for (const m of moves) {
                    const isOpponentCrown = (m.r === opponentCrownSpace.row && m.c === opponentCrownSpace.col);
                    if (piece.isCrowned && isOpponentCrown) continue;
                    if (!isOutOfBounds(m.r, m.c, gState) && !getPieceAt(m.r, m.c, gState) && !(m.r === ownCrownSpace.row && m.c === ownCrownSpace.col)) {
                        allActions.push({ type: 'move', pieceId: piece.id, r: m.r, c: m.c });
                    }
                }

                const attackDirs = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                for (const dir of attackDirs) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c, gState);
                    if(targetPiece && targetPiece.owner === opponentId && !isOutOfBounds(landingPos.r, landingPos.c, gState) && !getPieceAt(landingPos.r, landingPos.c, gState) && !(landingPos.r === ownCrownSpace.row && landingPos.c === ownCrownSpace.col)){
                        allActions.push({ type: 'attack', pieceId: piece.id, targetPos, landingPos });
                    }
                }

                if (piece.isCrowned) {
                     for (const dir1 of attackDirs) {
                        const op1Pos = { r: r + dir1.dr, c: c + dir1.dc };
                        const l1Pos = { r: r + dir1.dr * 2, c: c + dir1.dc * 2 };
                        const op1 = getPieceAt(op1Pos.r, op1Pos.c, gState);
                        if (op1?.owner === opponentId && !isOutOfBounds(l1Pos.r, l1Pos.c, gState) && !getPieceAt(l1Pos.r, l1Pos.c, gState) && !(l1Pos.r === ownCrownSpace.row && l1Pos.c === ownCrownSpace.col)) {
                            for (const dir2 of attackDirs) {
                                const op2Pos = { r: l1Pos.r + dir2.dr, c: l1Pos.c + dir2.dc };
                                const l2Pos = { r: l1Pos.r + dir2.dr * 2, c: l1Pos.c + dir2.dc * 2 };
                                const op2 = getPieceAt(op2Pos.r, op2Pos.c, gState);
                                if (op2?.owner === opponentId && op1.id !== op2.id && !isOutOfBounds(l2Pos.r, l2Pos.c, gState) && !getPieceAt(l2Pos.r, l2Pos.c, gState) && !(l2Pos.r === ownCrownSpace.row && l2Pos.c === ownCrownSpace.col)) {
                                    allActions.push({ type: 'double-stack', pieceId: piece.id, path: { opponent1: op1Pos, landing1: l1Pos, opponent2: op2Pos }, landingPos: l2Pos });
                                }
                            }
                        }
                    }
                }
            }
            return allActions;
        }

        function evaluateBoardState(gState, playerId) {
            const winInfo = checkForWin(gState);
            if(winInfo) {
                if(winInfo.winner === playerId) return Infinity;
                if(winInfo.winner !== playerId) return -Infinity;
            }
           
            const opponentId = playerId === 'p1' ? 'p2' : 'p1';
            const myPieces = gState.pieces.filter(p => p.owner === playerId);
            const oppPieces = gState.pieces.filter(p => p.owner === opponentId);
            const myCrownedCount = myPieces.filter(p => p.isCrowned).length;
            const oppCrownedCount = oppPieces.filter(p => p.isCrowned).length;

            let score = 0;
            const PIECE_VALUE = 100;
            const CROWNED_PIECE_VALUE = 300; // Increased value
            const POSITIONAL_VALUE_PER_ROW = 10; // Increased value
            const THREAT_VALUE = 35; // Increased value
            const SAFE_PIECE_BONUS = 5;

            score += myPieces.length * PIECE_VALUE;
            score -= oppPieces.length * PIECE_VALUE;
            score += myCrownedCount * CROWNED_PIECE_VALUE;
            score -= oppCrownedCount * CROWNED_PIECE_VALUE;
           
            for(const piece of myPieces) {
                const forwardProgress = (playerId === 'p1') ? (gState.boardSize.rows - 1 - piece.position.r) : piece.position.r;
                score += forwardProgress * POSITIONAL_VALUE_PER_ROW;
                if (!isSquareThreatenedBy(piece.position, opponentId, gState)) {
                    score += SAFE_PIECE_BONUS;
                }
            }
            for(const piece of oppPieces) {
                const forwardProgress = (opponentId === 'p1') ? (gState.boardSize.rows - 1 - piece.position.r) : piece.position.r;
                score -= forwardProgress * POSITIONAL_VALUE_PER_ROW;
            }

            score += getAllPossibleActions(playerId, gState).filter(a => a.type.includes('attack')).length * THREAT_VALUE;
            score -= getAllPossibleActions(opponentId, gState).filter(a => a.type.includes('attack')).length * (THREAT_VALUE + 5); // Being defensive is slightly more important

            return score;
        }

        function isSquareThreatenedBy(square, opponentPlayerId, gState) {
            const attackDirs = [{dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1}];
            const myPlayerId = opponentPlayerId === 'p1' ? 'p2' : 'p1';

            for (const dir of attackDirs) {
                const jumpOverPos = { r: square.r - dir.dr, c: square.c - dir.dc };
                const jumpFromPos = { r: square.r - dir.dr * 2, c: square.c - dir.dc * 2};

                const jumpingPiece = getPieceAt(jumpFromPos.r, jumpFromPos.c, gState);
                const pieceToJumpOver = getPieceAt(jumpOverPos.r, jumpOverPos.c, gState);
               
                if (jumpingPiece && jumpingPiece.owner === opponentPlayerId && pieceToJumpOver && pieceToJumpOver.owner === myPlayerId) {
                    return true;
                }
            }
            return false;
        }

        function applyActionToState(action, playerId, gState) {
            // Important: Use deep copy to not mutate the original state
            const newState = JSON.parse(JSON.stringify(gState));
            newState.turn = playerId; // Ensure turn is set for evaluation
           
            const piece = getPiece(action.pieceId, newState);
            const oldPos = piece.position;

            const movePieceInState = (p, r, c) => {
                const old = p.position;
                if(old && newState.board[old.r][old.c] === p.id) newState.board[old.r][old.c] = null;
                newState.board[r][c] = p.id;
                p.position = { r, c };
            };

            if (action.type === 'move') {
                movePieceInState(piece, action.r, action.c);
            } else if (action.type === 'attack') {
                const targetPiece = getPieceAt(action.targetPos.r, action.targetPos.c, newState);
                if (targetPiece.isCrowned) {
                    targetPiece.isCrowned = false;
                } else {
                    newState.board[action.targetPos.r][action.targetPos.c] = null;
                    newState.pieces = newState.pieces.filter(p => p.id !== targetPiece.id);
                    newState.players[playerId].capturedOpponentPieces++;
                }
                movePieceInState(piece, action.landingPos.r, action.landingPos.c);
            } else if (action.type === 'double-stack') {
                // Stage 1
                const defender1 = getPieceAt(action.path.opponent1.r, action.path.opponent1.c, newState);
                if (defender1.isCrowned) {
                    defender1.isCrowned = false;
                } else {
                    newState.board[action.path.opponent1.r][action.path.opponent1.c] = null;
                    newState.pieces = newState.pieces.filter(p => p.id !== defender1.id);
                    newState.players[playerId].capturedOpponentPieces++;
                }
                movePieceInState(piece, action.path.landing1.r, action.path.landing1.c);

                // Stage 2
                const defender2 = getPieceAt(action.path.opponent2.r, action.path.opponent2.c, newState);
                if (defender2.isCrowned) {
                    defender2.isCrowned = false;
                } else {
                    newState.board[action.path.opponent2.r][action.path.opponent2.c] = null;
                    newState.pieces = newState.pieces.filter(p => p.id !== defender2.id);
                    newState.players[playerId].capturedOpponentPieces++;
                }
               
                // Disassemble
                piece.isCrowned = false; // The original piece is now at landing1
                const newId = Math.max(0, ...newState.pieces.map(p => p.id)) + 1;
                const newPiece = { id: newId, owner: playerId, isCrowned: false, position: null };
                newState.pieces.push(newPiece);
                movePieceInState(newPiece, action.landingPos.r, action.landingPos.c); // New piece goes to landing2
            } else if (action.type === 'crown') {
                piece.isCrowned = true;
                newState.players[playerId].piecesInReserve--;
            } else if (action.type === 'reinforce') {
                const { newPiecePos, relocatedPiecePos } = action.placementData;
                const newId = Math.max(0, ...newState.pieces.map(p => p.id)) + 1;
                const newPiece = { id: newId, owner: playerId, isCrowned: false, position: null };
                newState.pieces.push(newPiece);
                movePieceInState(newPiece, newPiecePos.r, newPiecePos.c);
                newState.players[playerId].piecesInReserve--;
                movePieceInState(piece, relocatedPiecePos.r, relocatedPiecePos.c);
            }
            newState.turn = playerId === 'p1' ? 'p2' : 'p1';
            return newState;
        }

        function showDiceRoll(title) {
            return new Promise(resolve => {
                const modal = getEl('dice-modal');
                const svg = getEl('dice-svg');
                const text = svg.querySelector('.text');
                getEl('dice-title').textContent = title || 'Rolling...';
                const resultsEl = getEl('dice-results');
                resultsEl.innerHTML = '';
                modal.classList.add('visible');
                svg.classList.add('rolling');
                let tumbleInterval = setInterval(() => { text.textContent = Math.floor(Math.random() * 20) + 1; }, 60);
                setTimeout(() => {
                    clearInterval(tumbleInterval);
                    svg.classList.remove('rolling');
                    const roll = rollD20();
                    text.textContent = roll;
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        resolve(roll);
                    }, 1200);
                }, 1000);
            });
        }
       
        function addMessageToChat(message, sender) {
            const chatDisplay = getEl('ai-chat-display');
            const messageEl = document.createElement('div');
            messageEl.classList.add('chat-message', sender === 'ai' ? 'ai-message' : 'user-message');
            messageEl.innerHTML = message;
            chatDisplay.appendChild(messageEl);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
        }

        function generateAiHelp() {
            const chatDisplay = getEl('ai-chat-display');
            chatDisplay.innerHTML = '';
            const aiModal = getEl('aiModal');
           
            if (gameState.turn !== 'p1' || gameState.gamePhase !== 'PLAYING') {
                addMessageToChat("I can only give suggestions on your turn during the game. You can check the <b>‚ùì</b> button for general rules anytime!", 'ai');
                aiModal.classList.add('visible');
                return;
            }

            if (gameState.selectedPieceId === null) {
                addMessageToChat("Please select one of your pieces on the board, then click my button again. I'll give you the best moves for it!", 'ai');
            } else {
                const piece = getPiece(gameState.selectedPieceId);
                const { r, c } = piece.position;
                const possibleActions = getAllPossibleActions('p1', gameState).filter(a => a.pieceId === piece.id);

                if (possibleActions.length === 0) {
                     addMessageToChat(`The selected piece at ${formatCoords(r, c)} has no available moves or attacks.`, 'ai');
                } else {
                    let response = `For your piece at ${formatCoords(r, c)}, here are your options:<ul>`;
                   
                    possibleActions.forEach((action) => {
                        let text = '';
                        let priority = 'Safe Move';
                        if(action.type === 'move') {
                            text = `Move to ${formatCoords(action.r, action.c)}`;
                            if(action.r < r) priority = '<b>Good Move:</b> ';
                        } else if (action.type === 'attack') {
                            text = `Attack piece at ${formatCoords(action.targetPos.r, action.targetPos.c)}`;
                            priority = '<b>Top Priority:</b> ';
                        } else if (action.type === 'double-stack') {
                            text = `Double-Stack Attack starting with jump over ${formatCoords(action.path.opponent1.r, action.path.opponent1.c)}`;
                             priority = '<b>!!! Top Priority:</b> ';
                        }
                        response += `<li>${priority}${text}</li>`;
                    });
                    response += "</ul>";
                    addMessageToChat(response, 'ai');
                }
            }
            aiModal.classList.add('visible');
        }
       
        // --- Event Listeners ---
        gameBoardElement.addEventListener('click', handleBoardClick);
       
        const helpButton = getEl('help-button');
        const rulesModal = getEl('rulesModal');
        const closeRulesButton = getEl('close-rules-button');
        helpButton.onclick = () => rulesModal.classList.add('visible');
        closeRulesButton.onclick = () => rulesModal.classList.remove('visible');
        rulesModal.addEventListener('click', (event) => {
            if (event.target === rulesModal) rulesModal.classList.remove('visible');
        });

        const aiButton = getEl('ai-button');
        const aiModal = getEl('aiModal');
        const closeAiButton = getEl('close-ai-button');
        aiButton.onclick = generateAiHelp;
        closeAiButton.onclick = () => aiModal.classList.remove('visible');
        aiModal.addEventListener('click', (e) => { if(e.target === aiModal) aiModal.classList.remove('visible'); });

        const quitConfirmModal = getEl('quitConfirmModal');
        const quitConfirmYes = getEl('quitConfirmYes');
        const quitConfirmNo = getEl('quitConfirmNo');
        quitConfirmNo.onclick = () => quitConfirmModal.classList.remove('visible');
        quitConfirmYes.onclick = () => {
            quitConfirmModal.classList.remove('visible');
            setWinner('p2', 'You have forfeited the game.');
        };
       
        initializeGame();
    </script>
</body>
</html>
