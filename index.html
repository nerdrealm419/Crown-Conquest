<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crownfall (Official Rules)</title>
    <style>
        :root {
            --p1-color: #0096C7; /* Cerulean */
            --p2-color: #FF9F1C; /* Bright Orange */
            --background-color: #333;
            --panel-color: #444;
            --board-bg: #555;
            --cell-bg-light: #E0D8B0; /* Beige */
            --cell-bg-dark: #B4B8AB;  /* Light Grey */
            --highlight-move: #a2d2ff;
            --highlight-attack: #ffafcc;
            --highlight-pending-attack: #c9184a; /* Darker Red */
            --highlight-double-stack: #9b59b6; /* Purple */
            --highlight-placement: #bde0fe;
            --text-light: #eee;
            --text-dark: #1d3557;

            /* Sizing Variables for Responsiveness */
            --cell-size: 60px;
            --piece-size: 45px;
            --label-size: 30px;
            --crowned-ring-size: calc(var(--piece-size) * 0.8);
            --crowned-ring-top: calc((var(--piece-size) - var(--crowned-ring-size)) / 2);
        }
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; justify-content: center; align-items: center; min-height: 100vh; background-color: var(--background-color); color: var(--text-light); margin: 0; flex-direction: column; padding: 10px; box-sizing: border-box; }
        .game-container { display: flex; gap: 30px; align-items: flex-start; width: 100%; justify-content: center; }
        .info-panel { width: 220px; text-align: center; padding: 10px; background-color: var(--panel-color); border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.4); border: 3px solid transparent; transition: all 0.3s ease-in-out; }
        .active-turn-panel { border: 3px solid gold; box-shadow: 0 0 20px gold; transform: scale(1.02); }
        .info-panel h2 { display: flex; align-items: center; justify-content: center; gap: 10px; margin: 10px 0; }
        .color-swatch { width: 20px; height: 20px; border-radius: 50%; border: 2px solid #fff; }
        .captured-pieces-display { margin-top: 10px; padding-top: 10px; border-top: 1px solid #666; min-height: 60px; display: flex; flex-wrap: wrap; gap: 5px; justify-content: center; align-items: center;}
        .captured-icon { width: 25px; height: 25px; border-radius: 50%; border: 2px solid black; }
        #game-center { position: relative; display: flex; flex-direction: column; align-items: center; }

        #board-container {
            display: grid;
            grid-template-columns: var(--label-size) 1fr;
            grid-template-rows: var(--label-size) 1fr;
            grid-template-areas:
                ". col-headers"
                "row-headers game-board";
            align-items: center;
            justify-items: center;
            margin-top: 10px;
        }
        .grid-label { font-weight: bold; color: #ccc; }
        #col-headers { grid-area: col-headers; display: flex; width: 100%; }
        #col-headers .grid-label { width: calc(var(--cell-size) + 2px); text-align: center; }
        #row-headers { grid-area: row-headers; display: flex; flex-direction: column; height: 100%; }
        #row-headers .grid-label { height: calc(var(--cell-size) + 2px); display: flex; align-items: center; justify-content: center; }
        #gameBoard { grid-area: game-board; display: grid; grid-template-columns: repeat(7, var(--cell-size)); grid-template-rows: repeat(5, var(--cell-size)); border: 3px solid #666; background-color: var(--board-bg); gap: 2px; padding: 2px; border-radius: 5px; transition: opacity 0.5s; }

        .cell { width: var(--cell-size); height: var(--cell-size); display: flex; justify-content: center; align-items: center; box-sizing: border-box; border: 1px solid #777; position: relative; transition: background-color 0.2s; }
       
        .player-piece {
            width: var(--piece-size);
            height: var(--piece-size);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 16px;
            cursor: pointer;
            border: 3px solid black;
            box-sizing: border-box;
            transition: all 0.2s ease-in-out;
            position: relative;
        }
       
        .p1-piece { background-color: var(--p1-color); }
        .p2-piece { background-color: var(--p2-color); }
       
        .crowned { box-shadow: 0 0 15px gold; }
        .crowned::after {
            content: '';
            position: absolute;
            width: var(--crowned-ring-size); height: var(--crowned-ring-size);
            background-color: gold;
            border-radius: 50%;
            border: 2px solid #444;
            box-sizing: border-box;
            top: var(--crowned-ring-top); left: 50%;
            transform: translateX(-50%);
            z-index: 1;
            box-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
       
        .crown-icon { font-size: calc(var(--piece-size) * 0.7); position: absolute; text-shadow: 0 0 3px black; pointer-events: none; z-index: 2; }
        .selected { border: 4px solid #3498db; transform: scale(1.1); }
        .highlight-move { background-color: var(--highlight-move) !important; }
        .highlight-attack { background-color: var(--highlight-attack) !important; }
        .highlight-pending-attack { background-color: var(--highlight-pending-attack) !important; }
        .highlight-double-stack { background-color: var(--highlight-double-stack) !important; }
        .highlight-placement { background-color: var(--highlight-placement) !important; border: 2px dashed #3498db; }
        .player1-crown-spot, .player2-crown-spot { background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">👑</text></svg>'); background-size: 70%; background-repeat: no-repeat; background-position: center; opacity: 0.5; }
        #ui-panel { text-align: center; }
        #message { margin: 15px 0; font-size: 1.3em; color: #f1faee; font-weight: bold; min-height: 2em; }
        #rollDisplay { margin-top: 10px; font-size: 1.1em; font-weight: bold; min-height: 25px; color: #a8dadc; }
        #setup-choices { display: flex; gap: 10px; justify-content: center; margin-top: 10px; }
        .choice-group { border: 1px solid #888; padding: 10px; border-radius: 5px; }
        button { padding: 10px 20px; font-size: 1em; margin: 5px; cursor: pointer; border: none; border-radius: 5px; background-color: #457b9d; color: white; transition: background-color 0.2s; }
        button:hover { background-color: #a8dadc; color: var(--text-dark); }
        button:disabled { background-color: #666; color: #999; cursor: not-allowed; }
       
        #permanent-actions { margin-top: 15px; }
        #quitButton { background-color: #c1121f; }
        #quitButton:hover { background-color: #fca311; }
        #quitConfirmActions button { margin: 10px; }

        .modal { display: none; position: fixed; z-index: 100; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.6); justify-content: center; align-items: center; opacity: 0; transition: opacity 0.3s ease-in-out; }
        .modal.visible { display: flex; opacity: 1; }
        .modal-content { background-color: var(--panel-color); padding: 30px; border: 2px solid #888; width: 90%; max-width: 600px; text-align: center; border-radius: 10px; box-shadow: 0 0 25px rgba(0,0,0, 0.5); position: relative; overflow: hidden; }
        .modal-content h2, .modal-content h3 { color: #eee; }
        .modal-content p { font-size: 1.2em; }
       
        body.game-over #gameBoard { pointer-events: none; opacity: 0.6; }
        #loserAnimation { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; }
        .loser-icon { font-size: 80px; color: #e63946; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); z-index: 3; text-shadow: 2px 2px 5px rgba(0,0,0,0.5); }
        .raindrop { position: absolute; bottom: 100%; width: 2px; height: 30px; background: linear-gradient(to bottom, rgba(173, 216, 230, 0), rgba(173, 216, 230, 0.6)); animation: fall linear infinite; z-index: 2;}
        @keyframes fall { to { transform: translateY(200vh); } }

        #fireworks-container {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
        }
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            opacity: 0; /* Animation starts it */
            animation: firework-anim 1.2s ease-out forwards;
        }
        @keyframes firework-anim {
            0% {
                opacity: 1;
                transform: scale(0.3);
                /* Concentric rings start clustered */
                box-shadow: 0 0 5px 3px gold, 0 0 0 5px var(--p2-color), 0 0 0 10px var(--p1-color), 0 0 0 15px #ffafcc;
            }
            100% {
                opacity: 0;
                transform: scale(1.5);
                /* Rings expand and fade by having their spread radius grow and color become transparent */
                box-shadow: 0 0 10px 20px transparent, 0 0 0 30px transparent, 0 0 0 50px transparent, 0 0 0 70px transparent;
            }
        }

        #dice-modal-content { text-align: center; }
        #dice-container { margin-bottom: 20px; }
        #dice-svg { width: 150px; height: 150px; }
        #dice-svg .face { fill: #f1faee; stroke: #1d3557; stroke-width: 5; }
        #dice-svg .text { font-size: 50px; font-weight: bold; fill: #e63946; text-anchor: middle; dominant-baseline: central; }
        #dice-results { font-size: 1.2em; min-height: 1.5em; }
        #crownChoiceContent h3, #reinforceChoiceContent h3 { font-size: 1.8em; margin-top: 0; color: #fff; }
        #crownChoiceActions button, #reinforceChoiceActions button { margin: 10px; }

        @keyframes roll-animation {
            0% { transform: scale(0.5) rotate(0deg); }
            50% { transform: scale(1.2) rotate(540deg); }
            100% { transform: scale(1) rotate(720deg); }
        }
        .rolling { animation: roll-animation 1s ease-out; }
       
        .floating-button {
            width: 60px; height: 60px;
            color: white; border-radius: 50%; border: 2px solid white;
            display: flex; justify-content: center; align-items: center;
            font-size: 30px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.4); z-index: 101;
            transition: all 0.2s ease-in-out; position: fixed;
        }
        #help-button { bottom: 20px; right: 20px; background-color: #457b9d; }
        #help-button:hover { transform: scale(1.1); background-color: #a8dadc; color: #1d3557; }
       
        #ai-button { bottom: 20px; right: 100px; background-color: #e63946; }
        #ai-button:hover { transform: scale(1.1); background-color: #f1faee; color: #e63946;}
        #ai-chat-display {
            height: 300px; background-color: var(--background-color); border: 1px solid #666;
            border-radius: 5px; padding: 10px; overflow-y: auto;
            display: flex; flex-direction: column; gap: 10px; text-align: left;
        }
        .chat-message { padding: 8px 12px; border-radius: 15px; max-width: 80%; line-height: 1.4; word-wrap: break-word; }
        .user-message { background-color: #457b9d; color: white; align-self: flex-end; border-bottom-right-radius: 3px; }
        .ai-message { background-color: #666; color: white; align-self: flex-start; border-bottom-left-radius: 3px; }
        .ai-message ul { margin: 5px 0 5px 20px; padding: 0; }
        .ai-message li { margin-bottom: 5px; }
       
        #rules-content { text-align: left; padding: 0 20px; max-height: 70vh; overflow-y: auto; }
        #rules-content h3 { border-bottom: 1px solid #666; padding-bottom: 5px; margin-top: 20px; }
        #rules-content h4 { margin-bottom: 5px; margin-top: 15px; color: #a8dadc; }
        #rules-content ul, #rules-content ol { padding-left: 20px; margin-top: 5px; }
        #rules-content li { margin-bottom: 8px; }

        .modal-close-button {
            position: absolute; top: 10px; right: 15px;
            font-size: 30px; font-weight: bold; color: #ccc; cursor: pointer;
        }
        .modal-close-button:hover { color: white; }

        /* --- Mobile Responsiveness --- */
        @media (max-width: 768px) {
            :root {
                --cell-size: 45px;
                --piece-size: 35px;
                --label-size: 20px;
            }
            body { padding: 5px; }
            .game-container { flex-direction: column; align-items: center; gap: 15px; }
            .info-panel { width: 95%; max-width: 400px; order: 1; }
            #game-center { order: 2; }
            #p1_panel { order: 1; }
            #game-center { order: 2; }
            #p2_panel { order: 3; }

            .floating-button { width: 50px; height: 50px; font-size: 24px; }
             #help-button { right: 15px; bottom: 15px; }
             #ai-button { right: 80px; bottom: 15px; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div id="p1_panel" class="info-panel">
            <h2><div id="p1_swatch" class="color-swatch"></div> <span id="p1_header"></span></h2>
            <p>D20 Numbers: <b id="p1_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p1_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p1_captured_display" class="captured-pieces-display"></div>
        </div>
        <div id="game-center">
            <h1>Crownfall</h1>
            <div id="board-container">
                <div id="col-headers"></div>
                <div id="row-headers"></div>
                <div id="gameBoard"></div>
            </div>
            <div id="ui-panel">
                <div id="message"></div>
                <div id="rollDisplay"></div>
                <div id="setup-choices"></div>
                <div id="action-buttons"></div>
                <div id="permanent-actions"></div>
            </div>
        </div>
        <div id="p2_panel" class="info-panel">
            <h2><div id="p2_swatch" class="color-swatch"></div> <span id="p2_header"></span></h2>
            <p>D20 Numbers: <b id="p2_die_type"></b></p>
            <p>Pieces in Reserve: <b id="p2_reserve"></b></p>
            <p>Opponents Captured:</p>
            <div id="p2_captured_display" class="captured-pieces-display"></div>
        </div>
    </div>
   
    <!-- Modals -->
    <div id="dice-modal" class="modal"><div id="dice-modal-content" class="modal-content"><h3 id="dice-title">Rolling...</h3><div id="dice-container"><svg id="dice-svg" viewBox="0 0 100 100"><polygon class="face" points="50,1 95,25 95,75 50,99 5,75 5,25" /><text class="text" x="50" y="52">20</text></svg></div><div id="dice-results"></div></div></div>
    <div id="victoryModal" class="modal"><div id="victoryContent" class="modal-content"><div id="fireworks-container"></div><div id="loserAnimation" style="display: none;"><div class="loser-icon">😭</div></div><h2 id="victoryTitle"></h2><p id="victoryMessage"></p><div id="victoryActions"></div></div></div>
    <div id="crownChoiceModal" class="modal"><div id="crownChoiceContent" class="modal-content"><h3>You've Reached the Crown Space!</h3><p>You may Double-Stack this piece or place a Reinforcement from your reserve.</p><p>Reserve: <b id="crown-modal-reserve-count">X</b></p><div id="crownChoiceActions"></div></div></div>
    <div id="reinforceChoiceModal" class="modal"><div id="reinforceChoiceContent" class="modal-content"><h3>Choose Reinforcement Location</h3><p>Place a new piece to the left or right of your Crown Space.</p><div id="reinforceChoiceActions"></div></div></div>
    <div id="quitConfirmModal" class="modal"><div class="modal-content"><h3>Quit Game?</h3><p>Are you sure you want to forfeit? This will count as a loss.</p><div id="quitConfirmActions"><button id="quitConfirmYes">Yes, I Quit</button><button id="quitConfirmNo">No, Keep Playing</button></div></div></div>

    <!-- Floating Buttons and their Modals -->
    <div id="help-button" class="floating-button">❓</div>
    <div id="rulesModal" class="modal"><div class="modal-content"><span id="close-rules-button" class="modal-close-button">×</span><h2>Rules & Help</h2><div id="rules-content">
        <h3>1. Game Objective</h3>
        <p>Be the first player to either:</p>
        <ul>
            <li>Eliminate all of your opponent's pieces.</li>
            <li>Successfully create four crowned (double-stacked) pieces.</li>
        </ul>

        <h3>2. Game Components & Setup</h3>
        <h4>Grid Numbering (Row, Column)</h4>
        <ul>
            <li>The game is played on a 7x5 grid.</li>
            <li>Rows are labeled A–E (top to bottom) and columns 1–7 (left to right).</li>
            <li>Player 2 (Bot) starts on Row A. Player 1 (You) starts on Row E.</li>
        </ul>
        <h4>Setup Process</h4>
        <ol>
            <li>Each player starts with 4 pieces on the board and 12 in reserve.</li>
            <li>Players roll a D20 to see who goes first. The winner chooses their color and whether they are <b>"Even"</b> or <b>"Odd"</b> for die rolls. The high roller also moves first.</li>
            <li>Place your 4 starting pieces anywhere on your back row (Row E for Player 1, Row A for Player 2).</li>
            <li><b>CRITICAL:</b> A player may NOT place a starting piece on their own crown space (E,4 for Player 1; A,4 for Player 2).</li>
        </ol>
        <h4>The Crown Space</h4>
        <ul>
            <li>Each player has a designated crown space, represented by a crown icon.</li>
            <li><b>FORFEIT RULE:</b> A player may NOT occupy their own crown space at any time. Moving onto your own crown space results in an automatic forfeit of the game.</li>
        </ul>

        <h3>3. Piece Status & Management</h3>
        <h4>Crowning Pieces</h4>
        <ul>
            <li>When a regular piece reaches the opponent's crown space, you get a choice (if you have reserve pieces):
                <ol>
                    <li><b>Double-Stack:</b> Take a piece from your reserve and place it on top, creating a "Crowned" piece. This uses one reserve piece.</li>
                    <li><b>Reinforce:</b> Place a new, un-crowned piece from your reserve onto an empty space to the left or right of your OWN crown space. This uses one reserve piece.</li>
                </ol>
            </li>
            <li>A piece can only be double-stacked once.</li>
        </ul>
        <h4>Captured Pieces</h4>
        <ul>
            <li>Captured pieces are permanently removed from play but are kept on the side as trophies for the capturing player.</li>
        </ul>

        <h3>4. Movement & Attacks</h3>
        <h4>Basic Movement</h4>
        <ul>
            <li>Pieces move one square at a time, horizontally or vertically (forwards or backwards).</li>
        </ul>
        <h4>Basic Attack</h4>
        <ul>
            <li>Pieces attack by jumping <b>diagonally</b> over an opponent's piece to an empty square. The jumped piece is captured.</li>
        </ul>
        <h4>Chain Jump “Double-Stack Attack”</h4>
        <ul>
            <li>Can only be performed by a <b>crowned</b> piece.</li>
            <li>This attack allows a crowned piece to jump over <b>two</b> separate opponent pieces in a single turn.</li>
            <li>You must declare the Double-Stack Attack <b>before</b> rolling the die.</li>
            <li>If the attack roll is successful:
                <ul>
                    <li>Both jumped opponents are captured.</li>
                    <li>The crowned piece "disassembles" into two regular pieces.</li>
                    <li>One new piece lands on the empty square after the first opponent.</li>
                    <li>The second new piece lands on the empty square after the second opponent.</li>
                </ul>
            </li>
            <li>The two pieces are now separate, uncrowned units. The entire sequence requires only one successful roll.</li>
        </ul>

        <h3>5. Die Roll for Attack & Defense</h3>
        <h4>Attacking a Single Piece</h4>
        <ul>
            <li>The attacker rolls <b>1d20</b>. If the roll matches their type (Even/Odd), the attack succeeds.</li>
        </ul>
        <h4>Attacking a Crowned Piece (with a Single Piece)</h4>
        <ul>
            <li>The attacker rolls <b>3d20</b>. Two or more successful rolls are needed to un-crown the defender, reverting it to a single piece.</li>
        </ul>
        <h4>Attacking a Crowned Piece (with a Crowned Piece)</h4>
        <ul>
            <li>This is a "Best of 7" contest. The attacker rolls <b>7d20</b>.</li>
            <li>If the attacker gets <b>4+</b> successes (matching their type), the defender is uncrowned.</li>
            <li>If the defender's number is rolled <b>4+</b> times during the attacker's rolls, the <b>ATTACKER</b> is uncrowned instead.</li>
        </ul>
    </div></div></div>
    <div id="ai-button" class="floating-button">🤖</div>
    <div id="aiModal" class="modal"><div class="modal-content"><span id="close-ai-button" class="modal-close-button">×</span><h2>AI Assistant</h2><div id="ai-chat-display"></div></div></div>

    <script>
        const gameBoardElement = document.getElementById('gameBoard');
        const colHeadersElement = document.getElementById('col-headers');
        const rowHeadersElement = document.getElementById('row-headers');
        const messageElement = document.getElementById('message');
        const rollDisplayElement = document.getElementById('rollDisplay');
        const actionButtonsElement = document.getElementById('action-buttons');
        const permanentActionsContainer = document.getElementById('permanent-actions');
        const setupChoicesElement = document.getElementById('setup-choices');
        let gameState = {};

        const getEl = (id) => document.getElementById(id);
        const rollD20 = () => Math.floor(Math.random() * 20) + 1;
        const getPiece = (id) => gameState.pieces.find(p => p.id === id);
        const getPieceAt = (r, c) => {
            if (isOutOfBounds(r,c)) return null;
            const pieceId = gameState.board[r][c];
            return pieceId ? getPiece(pieceId) : null;
        };
        const isOutOfBounds = (r, c) => r < 0 || r >= gameState.boardSize.rows || c < 0 || c >= gameState.boardSize.cols;
       
        // --- NEW --- Helper function to format coordinates
        const formatCoords = (r, c) => `(${{0:'A', 1:'B', 2:'C', 3:'D', 4:'E'}[r]}, ${c + 1})`;

        function isOwnCrownSpace(player, r, c) {
            const ownCrown = (player === 'p1') ? gameState.crownSpaces.p1 : gameState.crownSpaces.p2;
            return ownCrown.row === r && ownCrown.col === c;
        }

        function movePieceOnBoard(piece, newR, newC) {
            if (!piece) return;
            // --- UPDATED --- Implement Forfeit Rule
            if (isOwnCrownSpace(piece.owner, newR, newC)) {
                console.error(`FORFEIT: Player ${piece.owner} moved to their own crown space at ${formatCoords(newR, newC)}.`);
                const winner = piece.owner === 'p1' ? 'p2' : 'p1';
                const loserName = piece.owner === 'p1' ? 'You' : 'The Bot';
                setWinner(winner, `${loserName} moved onto their own crown space and forfeited the game!`);
                return; // Stop further execution
            }
            const oldPos = piece.position;
            if(oldPos && gameState.board[oldPos.r] && gameState.board[oldPos.r][oldPos.c] === piece.id) {
                 gameState.board[oldPos.r][oldPos.c] = null;
            }
            gameState.board[newR][newC] = piece.id;
            piece.position = { r: newR, c: newC };
        }

        function render() {
            const p1Color = gameState.players.p1.color || 'transparent';
            const p2Color = gameState.players.p2.color || 'transparent';
            document.documentElement.style.setProperty('--p1-color', p1Color);
            document.documentElement.style.setProperty('--p2-color', p2Color);
            getEl('p1_swatch').style.backgroundColor = p1Color;
            getEl('p2_swatch').style.backgroundColor = p2Color;
            const p1Panel = getEl('p1_panel');
            const p2Panel = getEl('p2_panel');
            p1Panel.classList.toggle('active-turn-panel', gameState.turn === 'p1');
            p2Panel.classList.toggle('active-turn-panel', gameState.turn === 'p2');
            getEl('p1_header').textContent = `Player 1`;
            getEl('p2_header').textContent = `Player 2 (Bot)`;
            getEl('p1_die_type').textContent = gameState.players.p1.dieType ? gameState.players.p1.dieType.charAt(0).toUpperCase() + gameState.players.p1.dieType.slice(1) : 'N/A';
            getEl('p2_die_type').textContent = gameState.players.p2.dieType ? gameState.players.p2.dieType.charAt(0).toUpperCase() + gameState.players.p2.dieType.slice(1) : 'N/A';
            getEl('p1_reserve').textContent = gameState.players.p1.piecesInReserve;
            getEl('p2_reserve').textContent = gameState.players.p2.piecesInReserve;
            const p1CapturedContainer = getEl('p1_captured_display');
            p1CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p1.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p2Color;
                p1CapturedContainer.appendChild(capturedEl);
            }
            const p2CapturedContainer = getEl('p2_captured_display');
            p2CapturedContainer.innerHTML = '';
            for (let i = 0; i < gameState.players.p2.capturedOpponentPieces; i++) {
                const capturedEl = document.createElement('div');
                capturedEl.className = 'captured-icon';
                capturedEl.style.backgroundColor = p1Color;
                p2CapturedContainer.appendChild(capturedEl);
            }
            messageElement.textContent = gameState.message;
            rollDisplayElement.textContent = gameState.rollMessage || '';
            gameBoardElement.innerHTML = '';
           
            colHeadersElement.innerHTML = '';
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                const label = document.createElement('div');
                label.className = 'grid-label';
                label.textContent = c + 1;
                colHeadersElement.appendChild(label);
            }
            rowHeadersElement.innerHTML = '';
             // --- UPDATED --- Use letters for row headers
            const rowLabels = ['A', 'B', 'C', 'D', 'E'];
            for (let r = 0; r < gameState.boardSize.rows; r++) {
                const label = document.createElement('div');
                label.className = 'grid-label';
                label.textContent = rowLabels[r];
                rowHeadersElement.appendChild(label);
            }

            for (let r = 0; r < gameState.boardSize.rows; r++) {
                for (let c = 0; c < gameState.boardSize.cols; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                   
                    if ((r + c) % 2 === 0) {
                        cell.style.backgroundColor = 'var(--cell-bg-light)';
                    } else {
                        cell.style.backgroundColor = 'var(--cell-bg-dark)';
                    }

                    if (r === gameState.crownSpaces.p1.row && c === gameState.crownSpaces.p1.col) cell.classList.add('player1-crown-spot');
                    if (r === gameState.crownSpaces.p2.row && c === gameState.crownSpaces.p2.col) cell.classList.add('player2-crown-spot');
                    if (gameState.highlightedMoves.some(m => m.r === r && m.c === c)) cell.classList.add('highlight-move');
                    if (gameState.highlightedAttacks.some(a => a.landing.r === r && a.landing.c === c)) cell.classList.add('highlight-attack');
                    if (gameState.highlightedDoubleStackAttacks.some(p => p.r === r && p.c === c)) cell.classList.add('highlight-double-stack');
                    if (gameState.highlightedPendingAttack && gameState.highlightedPendingAttack.r === r && gameState.highlightedPendingAttack.c === c) cell.classList.add('highlight-pending-attack');
                    if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) cell.classList.add('highlight-placement');
                    const piece = getPieceAt(r, c);
                    if (piece) {
                        const pieceEl = document.createElement('div');
                        pieceEl.classList.add('player-piece', piece.owner === 'p1' ? 'p1-piece' : 'p2-piece');
                        pieceEl.dataset.pieceId = piece.id;
                        if (piece.isCrowned) {
                            pieceEl.classList.add('crowned');
                            const crownIcon = document.createElement('div');
                            crownIcon.classList.add('crown-icon');
                            crownIcon.textContent = '👑';
                            pieceEl.appendChild(crownIcon);
                        }
                        if (piece.id === gameState.selectedPieceId) pieceEl.classList.add('selected');
                        cell.appendChild(pieceEl);
                    }
                    gameBoardElement.appendChild(cell);
                }
            }
            setupChoicesElement.innerHTML = '';
            if (gameState.gamePhase === 'SETUP_CHOICE') {
                const colors = ['#0096C7', '#FF9F1C'];
                if (!gameState.players.p1.color) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose Color:</b>';
                    colors.forEach(color => {
                        const button = document.createElement('button');
                        button.textContent = color === '#0096C7' ? 'Cerulean' : 'Orange';
                        button.onclick = () => chooseColor(color);
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
                if (!gameState.players.p1.dieType) {
                    const group = document.createElement('div'); group.classList.add('choice-group');
                    group.innerHTML = '<b>Choose D20 Numbers:</b>';
                    ['Even', 'Odd'].forEach(type => {
                        const button = document.createElement('button');
                        button.textContent = type;
                        button.onclick = () => chooseDieType(type.toLowerCase());
                        group.appendChild(button);
                    });
                    setupChoicesElement.appendChild(group);
                }
            }
            actionButtonsElement.innerHTML = '';
            gameState.actions.forEach(action => {
                const button = document.createElement('button');
                button.textContent = action.text;
                button.onclick = action.onClick;
                button.disabled = action.disabled || false;
                actionButtonsElement.appendChild(button);
            });
            permanentActionsContainer.innerHTML = '';
            if (gameState.gamePhase === 'PLAYING' && gameState.turn === 'p1') {
                 const quitButton = document.createElement('button');
                 quitButton.id = 'quitButton';
                 quitButton.textContent = "Quit Game";
                 quitButton.onclick = () => getEl('quitConfirmModal').classList.add('visible');
                 permanentActionsContainer.appendChild(quitButton);
            }
        }
       
        function handleBoardClick(event) {
            if (gameState.gamePhase === 'GAME_OVER' || gameState.pendingMultiRoll) return;
            const pieceEl = event.target.closest('[data-piece-id]');
            const cellEl = event.target.closest('[data-row]');
            if (gameState.gamePhase === 'PLAYING' && gameState.turn === 'p1') {
                if (pieceEl) {
                    const pieceId = parseInt(pieceEl.dataset.pieceId);
                    const piece = getPiece(pieceId);
                    if (piece.owner === 'p1') selectPiece(pieceId);
                } else if (cellEl && gameState.selectedPieceId !== null) {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    declareMoveOrAttack(r, c);
                }
            } else if (gameState.gamePhase === 'SETUP_PLACEMENT') {
                if (cellEl && gameState.placingPlayer === 'p1') {
                    const r = parseInt(cellEl.dataset.row);
                    const c = parseInt(cellEl.dataset.col);
                    placeStartingPiece(r, c);
                }
            }
        }

        function initializeGame() {
            document.body.classList.remove('game-over');
            const loserAnimationContainer = getEl('loserAnimation');
            loserAnimationContainer.style.display = 'none';
            loserAnimationContainer.innerHTML = '<div class="loser-icon">😭</div>';

            const fireworksContainer = getEl('fireworks-container');
            if (fireworksContainer) {
                fireworksContainer.style.display = 'none';
                fireworksContainer.innerHTML = '';
            }

            gameState = {
                boardSize: { rows: 5, cols: 7 },
                board: Array(5).fill(0).map(() => Array(7).fill(null)),
                pieces: [],
                players: {
                    p1: { id: 'p1', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 },
                    p2: { id: 'p2', color: null, dieType: null, piecesInReserve: 12, capturedOpponentPieces: 0 }
                },
                // Player 2 starts on Row A (index 0), Player 1 on Row E (index 4)
                crownSpaces: { p1: { row: 4, col: 3 }, p2: { row: 0, col: 3 } },
                turn: null, gamePhase: 'SETUP_D20_ROLL', winner: null,
                message: "Let's begin! Roll to start the game.",
                rollMessage: '', selectedPieceId: null,
                highlightedMoves: [], highlightedAttacks: [], highlightedPlacements: [], highlightedPendingAttack: null, highlightedDoubleStackAttacks: [],
                pendingAttack: null, pendingDoubleStackAttack: null, pieceToCrownId: null,
                pendingMultiRoll: null,
                actions: [{ text: 'Roll to Start Game', onClick: setupRollOff }]
            };
            document.querySelectorAll('.modal').forEach(m => m.classList.remove('visible'));
            render();
        }
       
        async function setupRollOff() {
            gameState.actions = [];
            render();
            const p1Roll = await showDiceRoll("Player 1 Rolling...");
            const p2Roll = await showDiceRoll("Bot Rolling...");
            gameState.rollMessage = `Player 1 rolled a ${p1Roll}. Bot rolled a ${p2Roll}.`;
            let firstPlayer;
            if (p1Roll > p2Roll) {
                firstPlayer = 'p1';
                gameState.gamePhase = 'SETUP_CHOICE';
                gameState.message = 'You rolled higher! You will move first. Choose your color and D20 numbers.';
            } else if (p2Roll > p1Roll) {
                firstPlayer = 'p2';
                const botColor = Math.random() < 0.5 ? '#0096C7' : '#FF9F1C';
                const botDieType = Math.random() < 0.5 ? 'even' : 'odd';
                gameState.players.p2.color = botColor;
                gameState.players.p2.dieType = botDieType;
                gameState.players.p1.color = botColor === '#0096C7' ? '#FF9F1C' : '#0096C7';
                gameState.players.p1.dieType = botDieType === 'even' ? 'odd' : 'even';
                gameState.message = `Bot rolled higher and will move first. Bot has chosen its settings.`;
                startPlacementPhase(firstPlayer);
            } else {
                gameState.message = "It's a tie! Roll again.";
                gameState.actions = [{ text: 'Roll to Start Game', onClick: setupRollOff }];
            }
            gameState.turn = firstPlayer;
            render();
        }

        function chooseColor(color) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.color) return;
            gameState.players.p1.color = color;
            gameState.players.p2.color = color === '#0096C7' ? '#FF9F1C' : '#0096C7';
            checkSetupChoices();
        }
        function chooseDieType(type) {
            if (gameState.gamePhase !== 'SETUP_CHOICE' || gameState.players.p1.dieType) return;
            gameState.players.p1.dieType = type;
            gameState.players.p2.dieType = type === 'even' ? 'odd' : 'even';
            checkSetupChoices();
        }
        function checkSetupChoices() {
            if (gameState.players.p1.color && gameState.players.p1.dieType) {
                startPlacementPhase(gameState.turn);
            }
            render();
        }

        function startPlacementPhase(firstPlayer) {
            gameState.gamePhase = 'SETUP_PLACEMENT';
            gameState.placingPlayer = firstPlayer;
            gameState.piecesToPlace = 4;
            gameState.actions = [];
            if (firstPlayer === 'p2') {
                placeBotStartingPieces();
                gameState.placingPlayer = 'p1';
                 // --- UPDATED --- Use letter for row name
                gameState.message = "Bot has placed its pieces. Now, place your 4 pieces on your starting row (Row E).";
            } else {
                gameState.message = 'Your turn to place 4 pieces on your starting row (Row E).';
            }
            highlightPlacementSpots();
            render();
        }
       
        function highlightPlacementSpots() {
            gameState.highlightedPlacements = [];
            const player = gameState.placingPlayer;
            // Player 1 starts on row 4 (E), Player 2 on row 0 (A)
            const startRow = player === 'p1' ? gameState.boardSize.rows - 1 : 0;
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                if (!isOwnCrownSpace(player, startRow, c) && gameState.board[startRow][c] === null) {
                    gameState.highlightedPlacements.push({ r: startRow, c });
                }
            }
        }
       
        function placeStartingPiece(r, c) {
            if (gameState.highlightedPlacements.some(p => p.r === r && p.c === c)) {
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p1', isCrowned: false, position: { r, c } });
                gameState.board[r][c] = newId;
                gameState.piecesToPlace--;
                gameState.message = `Placed piece. ${gameState.piecesToPlace} remaining.`;
                if (gameState.piecesToPlace === 0) {
                    if (gameState.pieces.filter(p => p.owner === 'p2').length === 0) { placeBotStartingPieces(); }
                    setTimeout(startGame, 500);
                }
                highlightPlacementSpots();
                render();
            }
        }
       
        function placeBotStartingPieces() {
            const startRow = 0; // Bot starts on row A (index 0)
            const validCols = [];
            for (let c = 0; c < gameState.boardSize.cols; c++) {
                 if (!isOwnCrownSpace('p2', startRow, c)) {
                    validCols.push(c);
                }
            }
            let placed = 0;
            while (placed < 4 && validCols.length > 0) {
                const randIndex = Math.floor(Math.random() * validCols.length);
                const c = validCols.splice(randIndex, 1)[0];
                const newId = gameState.pieces.length + 1;
                gameState.pieces.push({ id: newId, owner: 'p2', isCrowned: false, position: { r: startRow, c } });
                gameState.board[startRow][c] = newId;
                placed++;
            }
        }

        function startGame() {
            gameState.gamePhase = 'PLAYING';
            gameState.highlightedPlacements = [];
            if (gameState.turn === 'p2') {
                gameState.message = `Bot moves first.`;
                setTimeout(botTurn, 1000);
            } else {
                gameState.message = `You move first. Select a piece.`;
            }
            gameState.actions = [];
            render();
        }

        function selectPiece(pieceId) {
            if (gameState.pendingDoubleStackAttack || gameState.gamePhase !== 'PLAYING') return;
            if (gameState.selectedPieceId === pieceId) {
                gameState.selectedPieceId = null;
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
                gameState.actions = [];
            } else {
                gameState.selectedPieceId = pieceId;
                const piece = getPiece(pieceId);
                const {r, c} = piece.position;
                const opponentCrownSpace = (piece.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
               
                // Calculate valid moves
                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                gameState.highlightedMoves = moves.filter(m => {
                    const isOpponentCrown = (m.r === opponentCrownSpace.row && m.c === opponentCrownSpace.col);
                    if (piece.isCrowned && isOpponentCrown) return false;
                    return !isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace(piece.owner, m.r, m.c);
                });
               
                // Calculate valid attacks
                const attackDirs = [ {dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1} ];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
                let hasDoubleStackAttack = false;

                // Regular single-jump attacks
                for (const dir of attackDirs) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                   
                    const isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) && !getPieceAt(landingPos.r, landingPos.c) && !isOwnCrownSpace(piece.owner, landingPos.r, landingPos.c);

                    if (targetPiece && targetPiece.owner !== piece.owner && isValidLanding) {
                        gameState.highlightedAttacks.push({ type: 'single', target: targetPos, landing: landingPos });
                    }
                }

                // Double-stack attacks (for crowned pieces only)
                if (piece.isCrowned) {
                    for (const dir1 of attackDirs) {
                        const opponent1Pos = { r: r + dir1.dr, c: c + dir1.dc };
                        const landing1Pos = { r: r + dir1.dr * 2, c: c + dir1.dc * 2 };
                        const opponent1 = getPieceAt(opponent1Pos.r, opponent1Pos.c);
                       
                        const isOpponentCrown1 = (landing1Pos.r === opponentCrownSpace.row && landing1Pos.c === opponentCrownSpace.col);
                        const isValidLanding1 = !isOutOfBounds(landing1Pos.r, landing1Pos.c) && !getPieceAt(landing1Pos.r, landing1Pos.c) && !isOwnCrownSpace(piece.owner, landing1Pos.r, landing1Pos.c) && !isOpponentCrown1;

                        if (opponent1 && opponent1.owner !== piece.owner && isValidLanding1) {
                            for (const dir2 of attackDirs) {
                                const opponent2Pos = { r: landing1Pos.r + dir2.dr, c: landing1Pos.c + dir2.dc };
                                const landing2Pos = { r: landing1Pos.r + dir2.dr * 2, c: c + dir2.dc * 2 };
                                const opponent2 = getPieceAt(opponent2Pos.r, opponent2Pos.c);

                                const isOpponentCrown2 = (landing2Pos.r === opponentCrownSpace.row && landing2Pos.c === opponentCrownSpace.col);
                                const isValidLanding2 = !isOutOfBounds(landing2Pos.r, landing2Pos.c) && !getPieceAt(landing2Pos.r, landing2Pos.c) && !isOwnCrownSpace(piece.owner, landing2Pos.r, landing2Pos.c) && !isOpponentCrown2;

                                if (opponent2 && opponent2.owner !== piece.owner && opponent2.id !== opponent1.id && isValidLanding2) {
                                    hasDoubleStackAttack = true;
                                    gameState.highlightedAttacks.push({
                                        type: 'double-stack',
                                        landing: landing2Pos,
                                        path: { opponent1: opponent1Pos, landing1: landing1Pos, opponent2: opponent2Pos }
                                    });
                                    gameState.highlightedDoubleStackAttacks.push(landing2Pos);
                                }
                            }
                        }
                    }
                }
               
                gameState.actions = [];
                if (hasDoubleStackAttack) {
                     gameState.actions.push({ text: 'Declare Double-Stack Attack', onClick: () => declareDoubleStackAttack() });
                }
            }
            render();
        }
       
        function declareDoubleStackAttack() {
            if (!gameState.selectedPieceId) return;
            const piece = getPiece(gameState.selectedPieceId);
            if (!piece || !piece.isCrowned) return;

            gameState.pendingDoubleStackAttack = { pieceId: gameState.selectedPieceId };
            gameState.message = "Double-Stack Attack declared! Click a purple square to perform the multi-jump.";
           
            gameState.highlightedAttacks = gameState.highlightedAttacks.filter(a => a.type === 'double-stack');
            gameState.highlightedMoves = [];
           
            gameState.actions = [{ text: "Cancel Attack", onClick: cancelAttack }];
            render();
        }

        function declareMoveOrAttack(r, c) {
            const attack = gameState.highlightedAttacks.find(a => a.landing.r === r && a.landing.c === c);
            const move = gameState.highlightedMoves.find(m => m.r === r && m.c === c);
           
            if (move && !gameState.pendingDoubleStackAttack) {
                executeMove(gameState.selectedPieceId, move.r, move.c);
                return;
            }

            if (attack) {
                gameState.highlightedPendingAttack = { r: attack.landing.r, c: attack.landing.c };
               
                if (attack.type === 'double-stack') {
                    if (!gameState.pendingDoubleStackAttack) {
                        gameState.message = "You must declare a Double-Stack Attack first using the button.";
                        render();
                        return;
                    }
                    gameState.pendingDoubleStackAttack.path = attack.path;
                    gameState.pendingDoubleStackAttack.landingPos = attack.landing;
                    gameState.message = "Roll to start your Double-Stack Attack!";
                } else {
                    gameState.pendingAttack = { pieceId: gameState.selectedPieceId, targetPos: attack.target, landingPos: attack.landing };
                    gameState.message = "You have declared an attack!";
                }
               
                gameState.actions = [
                    { text: "Roll to Attack", onClick: startAttack },
                    { text: "Cancel Attack", onClick: cancelAttack }
                ];
                gameState.highlightedMoves = [];
                gameState.highlightedAttacks = [];
                gameState.highlightedDoubleStackAttacks = [];
            }
            render();
        }
       
        function cancelAttack() {
            const pieceId = gameState.selectedPieceId;
            gameState.pendingAttack = null;
            gameState.pendingDoubleStackAttack = null;
            gameState.highlightedPendingAttack = null;
            gameState.message = "Attack canceled. Select a move or another attack.";
            selectPiece(pieceId);
        }

        function executeMove(pieceId, r, c) {
            const piece = getPiece(pieceId);
            movePieceOnBoard(piece, r, c);
            // Check for forfeit is now inside movePieceOnBoard, if a winner is decided, stop.
            if(gameState.winner) return;

            const oppCrown = gameState.crownSpaces[piece.owner === 'p1' ? 'p2' : 'p1'];
            if (r === oppCrown.row && c === oppCrown.col) {
                enterCrowningPhase(pieceId);
            } else {
                endTurn();
            }
        }
       
        async function startAttack() {
            const isDoubleStack = !!gameState.pendingDoubleStackAttack;
            const attackData = isDoubleStack ? gameState.pendingDoubleStackAttack : gameState.pendingAttack;
            if (!attackData) return;

            gameState.actions = [];
            render();

            const attacker = getPiece(attackData.pieceId);
            const defender = !isDoubleStack ? getPieceAt(attackData.targetPos.r, attackData.targetPos.c) : null;
           
            let numRolls = 1;
            if (!isDoubleStack && attacker.isCrowned && defender.isCrowned) numRolls = 7;
            else if (!isDoubleStack && !attacker.isCrowned && defender.isCrowned) numRolls = 3;

            if (numRolls === 1) {
                const roll = await showDiceRoll(`${attacker.owner === 'p1' ? 'Player 1' : 'Bot'} Attacking...`);
                const isSuccess = (gameState.players[attacker.owner].dieType === 'even' && roll % 2 === 0) || (gameState.players[attacker.owner].dieType === 'odd' && roll % 2 !== 0);
               
                if (isDoubleStack) {
                    if (isSuccess) { resolveDoubleStackAttack(attackData); }
                    else {
                        gameState.message = "Double-Stack Attack failed! The attack was unsuccessful.";
                        setTimeout(endTurn, 2000);
                    }
                    return;
                }

                if(isSuccess) {
                    gameState.message = "Attack successful!";
                    gameState.players[attacker.owner].capturedOpponentPieces++;
                    gameState.board[attackData.targetPos.r][attackData.targetPos.c] = null;
                    gameState.pieces = gameState.pieces.filter(p => p.id !== defender.id);
                    movePieceOnBoard(attacker, attackData.landingPos.r, attackData.landingPos.c);
                    if(gameState.winner) return; // Forfeit check
                    const oppCrown = (attacker.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
                    if (attackData.landingPos.r === oppCrown.row && attackData.landingPos.c === oppCrown.col) {
                        enterCrowningPhase(attacker.id);
                    } else {
                        setTimeout(endTurn, 2000);
                    }
                } else {
                    gameState.message = "Attack failed!";
                    setTimeout(endTurn, 2000);
                }
            } else {
                gameState.pendingMultiRoll = { attackData, rollsNeeded: numRolls, rollsMade: 0, successes: 0, defenderSuccesses: 0 };
                gameState.message = `Attack initiated! Need to roll ${numRolls} dice.`;
                gameState.rollMessage = `Successes: 0 / ${numRolls} rolls made`;
                if(gameState.turn === 'p1') {
                    gameState.actions = [{text: `Roll Die (1 of ${numRolls})`, onClick: executeSingleRoll}];
                } else { setTimeout(executeSingleRoll, 1000); }
                render();
            }
        }
       
        async function executeSingleRoll() {
            if (!gameState.pendingMultiRoll) return;

            const multiRoll = gameState.pendingMultiRoll;
            gameState.actions = [];
            render();

            const attackerId = getPiece(multiRoll.attackData.pieceId).owner;
            const defenderId = attackerId === 'p1' ? 'p2' : 'p1';
            const roll = await showDiceRoll(`${attackerId === 'p1' ? 'Player 1' : 'Bot'} rolling...`);
           
            multiRoll.rollsMade++;
            const isAttackerSuccess = (gameState.players[attackerId].dieType === 'even' && roll % 2 === 0) || (gameState.players[attackerId].dieType === 'odd' && roll % 2 !== 0);
            const isDefenderSuccess = (gameState.players[defenderId].dieType === 'even' && roll % 2 === 0) || (gameState.players[defenderId].dieType === 'odd' && roll % 2 !== 0);

            if (isAttackerSuccess) multiRoll.successes++;
            if (multiRoll.rollsNeeded === 7 && isDefenderSuccess) multiRoll.defenderSuccesses++;

            gameState.message = `Roll ${multiRoll.rollsMade} of ${multiRoll.rollsNeeded} was a ${roll}.`;
            let successMsg = `Attacker Successes: ${multiRoll.successes}`;
            if (multiRoll.rollsNeeded === 7) successMsg += ` | Defender Successes: ${multiRoll.defenderSuccesses}`;
            gameState.rollMessage = successMsg;

            if (multiRoll.rollsMade >= multiRoll.rollsNeeded) {
                resolveMultiRollAttack();
            } else {
                if (gameState.turn === 'p1') {
                    gameState.actions = [{text: `Roll Die (${multiRoll.rollsMade + 1} of ${multiRoll.rollsNeeded})`, onClick: executeSingleRoll}];
                } else {
                    setTimeout(executeSingleRoll, 1500);
                }
            }
            render();
        }

        function resolveMultiRollAttack() {
            const { attackData, rollsNeeded, successes, defenderSuccesses } = gameState.pendingMultiRoll;
            const attacker = getPiece(attackData.pieceId);
            const defender = getPieceAt(attackData.targetPos.r, attackData.targetPos.c);
            let message = "";

            if (rollsNeeded === 3) { // Single vs Crowned
                if (successes >= 2) {
                    defender.isCrowned = false;
                    message = `Attack successful! (${successes}/3) Defender is uncrowned.`;
                } else {
                    message = `Attack failed! (${successes}/3) Defender is safe.`;
                }
            } else if (rollsNeeded === 7) { // Crowned vs Crowned
                if (successes >= 4) {
                    defender.isCrowned = false;
                    message = `Crowned attack successful! (${successes} vs ${defenderSuccesses}) Defender is uncrowned.`;
                } else if (defenderSuccesses >= 4) {
                    attacker.isCrowned = false;
                    message = `Crowned attack FAILED! (${successes} vs ${defenderSuccesses}) Your piece is uncrowned.`;
                } else {
                    message = `Roll-off is a draw (${successes} to ${defenderSuccesses}). No pieces are changed.`;
                }
            }
            gameState.message = message;
            setTimeout(endTurn, 2500);
        }

        function resolveDoubleStackAttack(attackData) {
            const { pieceId, path, landingPos } = attackData;
            const attacker = getPiece(pieceId);
           
            if (!attacker || !path || !landingPos) {
                console.error("Could not resolve double stack attack, missing data.", attackData);
                endTurn();
                return;
            }

            const { opponent1, landing1, opponent2 } = path;
            const landing2 = landingPos;

            const defender1 = getPieceAt(opponent1.r, opponent1.c);
            const defender2 = getPieceAt(opponent2.r, opponent2.c);

            gameState.board[opponent1.r][opponent1.c] = null;
            gameState.board[opponent2.r][opponent2.c] = null;
            gameState.pieces = gameState.pieces.filter(p => p.id !== defender1.id && p.id !== defender2.id);
            gameState.players[attacker.owner].capturedOpponentPieces += 2;

            gameState.board[attacker.position.r][attacker.position.c] = null;
           
            attacker.isCrowned = false;
            attacker.position = null;
            movePieceOnBoard(attacker, landing1.r, landing1.c);
            if(gameState.winner) return;

            const newPieceId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
            const newPiece = { id: newPieceId, owner: attacker.owner, isCrowned: false, position: null };
            gameState.pieces.push(newPiece);
            movePieceOnBoard(newPiece, landing2.r, landing2.c);
            if(gameState.winner) return;


            gameState.message = "Double-Stack Attack successful! The piece split and captured two opponents.";
           
            const oppCrown = (attacker.owner === 'p1') ? gameState.crownSpaces.p2 : gameState.crownSpaces.p1;
            if (landing1.r === oppCrown.row && landing1.c === oppCrown.col) {
                enterCrowningPhase(attacker.id);
            } else if (newPiece.position.r === oppCrown.row && newPiece.position.c === oppCrown.col) {
                enterCrowningPhase(newPiece.id);
            } else {
                setTimeout(endTurn, 2500);
            }
        }
       
        function promptReinforceChoice() {
            getEl('crownChoiceModal').classList.remove('visible');
            const reinforceModal = getEl('reinforceChoiceModal');
            const actionsContainer = getEl('reinforceChoiceActions');
            actionsContainer.innerHTML = '';
           
            const player = getPiece(gameState.pieceToCrownId).owner;
            const ownCrownSpace = gameState.crownSpaces[player];
            const leftSpotFree = !isOutOfBounds(ownCrownSpace.row, ownCrownSpace.col - 1) && !getPieceAt(ownCrownSpace.row, ownCrownSpace.col - 1);
            const rightSpotFree = !isOutOfBounds(ownCrownSpace.row, ownCrownSpace.col + 1) && !getPieceAt(ownCrownSpace.row, ownCrownSpace.col + 1);

            if (leftSpotFree) {
                const leftButton = document.createElement('button');
                leftButton.textContent = "Place Left";
                leftButton.onclick = () => { reinforceModal.classList.remove('visible'); resolveCrowning('reinforce', 'left'); };
                actionsContainer.appendChild(leftButton);
            }
            if (rightSpotFree) {
                const rightButton = document.createElement('button');
                rightButton.textContent = "Place Right";
                rightButton.onclick = () => { reinforceModal.classList.remove('visible'); resolveCrowning('reinforce', 'right'); };
                actionsContainer.appendChild(rightButton);
            }
            if (!leftSpotFree && !rightSpotFree) {
                actionsContainer.innerHTML = "<p>No available space to place a reinforcement.</p>";
                setTimeout(() => { reinforceModal.classList.remove('visible'); endTurn(); }, 2000);
            }
            reinforceModal.classList.add('visible');
        }

        function enterCrowningPhase(pieceId) {
            gameState.gamePhase = 'AWAITING_CROWNING_CHOICE';
            gameState.pieceToCrownId = pieceId;
            const piece = getPiece(pieceId);
            if (!piece || piece.isCrowned) {
                endTurn();
                return;
            }

            const player = piece.owner;
            const playerObj = gameState.players[player];
            const hasReserves = playerObj.piecesInReserve > 0;
           
            gameState.message = `${player === 'p1' ? 'You have' : 'Bot has'} reached the opponent's crown space!`;
            gameState.actions = [];
            render();

            if (player === 'p1') {
                const crownModal = getEl('crownChoiceModal');
                const actionsContainer = getEl('crownChoiceActions');
                actionsContainer.innerHTML = '';
                getEl('crown-modal-reserve-count').textContent = playerObj.piecesInReserve;
               
                const crownButton = document.createElement('button');
                crownButton.textContent = "Double-Stack";
                crownButton.onclick = () => { crownModal.classList.remove('visible'); resolveCrowning('crown'); };
                crownButton.disabled = !hasReserves;
                actionsContainer.appendChild(crownButton);

                const reinforceButton = document.createElement('button');
                reinforceButton.textContent = "Place Reinforcement";
                reinforceButton.onclick = () => promptReinforceChoice();
                reinforceButton.disabled = !hasReserves;
                actionsContainer.appendChild(reinforceButton);
               
                if (!hasReserves) {
                    const noActionInfo = document.createElement('p');
                    noActionInfo.textContent = "You have no pieces in reserve to take an action.";
                    actionsContainer.appendChild(noActionInfo);
                     setTimeout(() => { crownModal.classList.remove('visible'); resolveCrowning('none'); }, 2500);
                }
                crownModal.classList.add('visible');
            } else {
                setTimeout(() => {
                    const ownCrownSpace = gameState.crownSpaces.p2;
                    const leftSpotFree = !isOutOfBounds(ownCrownSpace.row, ownCrownSpace.col-1) && !getPieceAt(ownCrownSpace.row, ownCrownSpace.col - 1);
                    const rightSpotFree = !isOutOfBounds(ownCrownSpace.row, ownCrownSpace.col+1) && !getPieceAt(ownCrownSpace.row, ownCrownSpace.col + 1);
                    const canReinforce = hasReserves && (leftSpotFree || rightSpotFree);
                   
                    if (canReinforce && Math.random() > 0.5) {
                        const availableDirections = [];
                        if (leftSpotFree) availableDirections.push('left');
                        if (rightSpotFree) availableDirections.push('right');
                        const direction = availableDirections[Math.floor(Math.random() * availableDirections.length)];
                        resolveCrowning('reinforce', direction);
                    } else if (hasReserves) {
                        resolveCrowning('crown');
                    } else {
                        resolveCrowning('none');
                    }
                }, 1500);
            }
        }

        function resolveCrowning(choice, direction = null) {
            const piece = getPiece(gameState.pieceToCrownId);
            if (!piece) { endTurn(); return; }
            const player = piece.owner;
            const playerObj = gameState.players[player];

            if (choice === 'crown') {
                piece.isCrowned = true;
                playerObj.piecesInReserve--;
                gameState.message = `${player === 'p1' ? 'Your' : "The Bot's"} piece has been Double-Stacked!`;
            } else if (choice === 'reinforce' && direction) {
                const ownCrownSpace = gameState.crownSpaces[player];
                const placementCol = direction === 'left' ? ownCrownSpace.col - 1 : ownCrownSpace.col + 1;
               
                const newId = Math.max(0, ...gameState.pieces.map(p => p.id)) + 1;
                gameState.pieces.push({ id: newId, owner: player, isCrowned: false, position: { r: ownCrownSpace.row, c: placementCol } });
                movePieceOnBoard(getPiece(newId), ownCrownSpace.row, placementCol);
                playerObj.piecesInReserve--;
                gameState.message = `${player === 'p1' ? 'You' : "The Bot"} placed a reinforcement to the ${direction} of ${player === 'p1' ? 'your' : "its"} crown.`;
            } else {
                 gameState.message = "No reserve action was taken.";
            }
            gameState.gamePhase = 'PLAYING';
            gameState.pieceToCrownId = null;
            endTurn();
        }

        function checkForWin() {
            if (gameState.pieces.filter(p => p.owner === 'p1').length === 0) { setWinner('p2', 'The Bot eliminated all of your pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p2').length === 0) { setWinner('p1', 'You eliminated all opponent pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p1' && p.isCrowned).length >= 4) { setWinner('p1', 'You have 4 crowned pieces!'); return true; }
            if (gameState.pieces.filter(p => p.owner === 'p2' && p.isCrowned).length >= 4) { setWinner('p2', 'The Bot has 4 crowned pieces!'); return true; }
            return false;
        }

        function setWinner(winner, message) {
            gameState.gamePhase = 'GAME_OVER';
            gameState.winner = winner;
            document.body.classList.add('game-over');
            const modal = getEl('victoryModal');
            getEl('victoryTitle').textContent = winner === 'p1' ? 'VICTORY!' : 'DEFEAT!';
            getEl('victoryMessage').textContent = message;
           
            const fireworksContainer = getEl('fireworks-container');
            const loserAnimationContainer = getEl('loserAnimation');
            fireworksContainer.innerHTML = '';

            if (winner === 'p1') {
                loserAnimationContainer.style.display = 'none';
                fireworksContainer.style.display = 'block';

                const numFireworks = 25;
                for (let i = 0; i < numFireworks; i++) {
                    const firework = document.createElement('div');
                    firework.className = 'firework';
                    firework.style.top = (10 + Math.random() * 80) + '%';
                    firework.style.left = (10 + Math.random() * 80) + '%';
                    firework.style.transform = `scale(${0.5 + Math.random()})`;
                    firework.style.animationDelay = (Math.random() * 2) + 's';
                    fireworksContainer.appendChild(firework);
                }
            } else {
                fireworksContainer.style.display = 'none';
                loserAnimationContainer.style.display = 'block';
                loserAnimationContainer.innerHTML = '<div class="loser-icon">😭</div>';
                for (let i = 0; i < 50; i++) {
                    const drop = document.createElement('div');
                    drop.className = 'raindrop';
                    drop.style.left = Math.random() * 100 + '%';
                    drop.style.animationDelay = Math.random() * 2 + 's';
                    drop.style.animationDuration = 0.5 + Math.random() * 0.5 + 's';
                    loserAnimationContainer.appendChild(drop);
                }
            }
           
            const actions = getEl('victoryActions');
            actions.innerHTML = '';
            const button = document.createElement('button');
            button.textContent = "Play Again?";
            button.onclick = initializeGame;
            actions.appendChild(button);
            modal.classList.add('visible');
            render();
        }

        function endTurn() {
            gameState.selectedPieceId = null;
            gameState.highlightedMoves = [];
            gameState.highlightedAttacks = [];
            gameState.highlightedPendingAttack = null;
            gameState.highlightedDoubleStackAttacks = [];
            gameState.pendingAttack = null;
            gameState.pendingDoubleStackAttack = null;
            gameState.pendingMultiRoll = null;
            gameState.actions = [];
            gameState.rollMessage = '';
            if (checkForWin()) return;
            gameState.turn = gameState.turn === 'p1' ? 'p2' : 'p1';
            gameState.message = `${gameState.turn === 'p1' ? 'Your' : "Bot's"} turn to move.`;
            render();
            if (gameState.turn === 'p2' && gameState.gamePhase === 'PLAYING') setTimeout(botTurn, 2000);
        }
       
        function botTurn() {
            if(gameState.winner) return; // Don't let bot move if game is over
            const myPieces = gameState.pieces.filter(p => p.owner === 'p2');
            let possibleActions = [];
            myPieces.forEach(piece => {
                const {r, c} = piece.position;
                const opponentCrownSpace = gameState.crownSpaces.p1;

                const moves = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                moves.forEach(m => {
                     if (piece.isCrowned && m.r === opponentCrownSpace.row && m.c === opponentCrownSpace.col) return;
                    if (!isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace('p2', m.r, m.c)) {
                        possibleActions.push({ type: 'move', pieceId: piece.id, r: m.r, c: m.c });
                    }
                });
                const attacks = [{dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1}];
                for (const dir of attacks) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                   
                    let isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) && !getPieceAt(landingPos.r, landingPos.c) && !isOwnCrownSpace('p2', landingPos.r, landingPos.c);
                   
                    if(targetPiece && targetPiece.owner === 'p1' && isValidLanding){
                        possibleActions.push({ type: 'attack', pieceId: piece.id, targetPos, landingPos });
                    }
                }
            });

            if (possibleActions.length > 0) {
                const attackActions = possibleActions.filter(a => a.type === 'attack');
                const moveActions = possibleActions.filter(a => a.type === 'move');
                const chosenAction = attackActions.length > 0 ? attackActions[Math.floor(Math.random() * attackActions.length)] : moveActions[Math.floor(Math.random() * moveActions.length)];
               
                if (chosenAction.type === 'move') { executeMove(chosenAction.pieceId, chosenAction.r, chosenAction.c); }
                else { gameState.pendingAttack = chosenAction; startAttack(); }
            } else { gameState.message = "Bot has no valid moves."; setTimeout(endTurn, 1500); }
        }

        function showDiceRoll(title) {
            return new Promise(resolve => {
                const modal = getEl('dice-modal');
                const svg = getEl('dice-svg');
                const text = svg.querySelector('.text');
                getEl('dice-title').textContent = title || 'Rolling...';
                const resultsEl = getEl('dice-results');
                resultsEl.innerHTML = '';
                modal.classList.add('visible');
                svg.classList.add('rolling');
                let tumbleInterval = setInterval(() => { text.textContent = Math.floor(Math.random() * 20) + 1; }, 60);
                setTimeout(() => {
                    clearInterval(tumbleInterval);
                    svg.classList.remove('rolling');
                    const roll = rollD20();
                    text.textContent = roll;
                    setTimeout(() => {
                        modal.classList.remove('visible');
                        resolve(roll);
                    }, 1200);
                }, 1000);
            });
        }
       
        function addMessageToChat(message, sender) {
            const chatDisplay = getEl('ai-chat-display');
            const messageEl = document.createElement('div');
            messageEl.classList.add('chat-message', sender === 'ai' ? 'ai-message' : 'user-message');
            messageEl.innerHTML = message;
            chatDisplay.appendChild(messageEl);
            chatDisplay.scrollTop = chatDisplay.scrollHeight;
        }

        function generateAiHelp() {
            const chatDisplay = getEl('ai-chat-display');
            chatDisplay.innerHTML = '';
            const aiModal = getEl('aiModal');
           
            if (gameState.turn !== 'p1' || gameState.gamePhase !== 'PLAYING') {
                addMessageToChat("I can only give suggestions on your turn during the game. You can check the <b>❓</b> button for general rules anytime!", 'ai');
                aiModal.classList.add('visible');
                return;
            }

            if (gameState.selectedPieceId === null) {
                addMessageToChat("Please select one of your pieces on the board, then click my button again. I'll give you the best moves for it!", 'ai');
            } else {
                const piece = getPiece(gameState.selectedPieceId);
                const { r, c } = piece.position;
                const opponentId = 'p2';
                let possibleActions = [];

                const attackOffsets = [{dr: -1, dc: -1}, {dr: -1, dc: 1}, {dr: 1, dc: -1}, {dr: 1, dc: 1}];
                for (const dir of attackOffsets) {
                    const targetPos = {r: r + dir.dr, c: c + dir.dc};
                    const targetPiece = getPieceAt(targetPos.r, targetPos.c);
                    const landingPos = {r: r + dir.dr * 2, c: c + dir.dc * 2};
                    let isValidLanding = !isOutOfBounds(landingPos.r, landingPos.c) && !getPieceAt(landingPos.r, landingPos.c) && !isOwnCrownSpace(piece.owner, landingPos.r, landingPos.c);
                    if(targetPiece && targetPiece.owner === opponentId && isValidLanding){
                        // --- UPDATED --- Use formatted coords for AI help
                       possibleActions.push({ text: `Attack piece at ${formatCoords(targetPos.r, targetPos.c)}`, score: 3 });
                    }
                }

                const moveOffsets = [{r: r+1, c}, {r: r-1, c}, {r: r, c: c+1}, {r: r, c: c-1}];
                moveOffsets.forEach(m => {
                    if (!isOutOfBounds(m.r, m.c) && !getPieceAt(m.r, m.c) && !isOwnCrownSpace(piece.owner, m.r, m.c)) {
                        let score = 1;
                        if (m.r < r) score = 2; // Prioritize forward movement
                        // --- UPDATED --- Use formatted coords for AI help
                        possibleActions.push({ text: `Move to ${formatCoords(m.r, m.c)}`, score: score });
                    }
                });

                if (possibleActions.length === 0) {
                     addMessageToChat(`The selected piece at ${formatCoords(c, r)} has no available moves or attacks.`, 'ai');
                } else {
                    possibleActions.sort((a, b) => b.score - a.score);
                    let response = `For your piece at ${formatCoords(r, c)}, here are your options:<ul>`;
                    possibleActions.forEach((action) => {
                        let prefix = "";
                        if (action.score >= 3) prefix = "<b>Top Priority:</b> ";
                        else if (action.score >= 2) prefix = "<b>Good Move:</b> ";
                        else prefix = "Safe Move: ";
                        response += `<li>${prefix}${action.text}</li>`;
                    });
                    response += "</ul>";
                    addMessageToChat(response, 'ai');
                }
            }
            aiModal.classList.add('visible');
        }
       
        // --- Event Listeners ---
        gameBoardElement.addEventListener('click', handleBoardClick);
       
        const helpButton = getEl('help-button');
        const rulesModal = getEl('rulesModal');
        const closeRulesButton = getEl('close-rules-button');
        helpButton.onclick = () => rulesModal.classList.add('visible');
        closeRulesButton.onclick = () => rulesModal.classList.remove('visible');
        rulesModal.addEventListener('click', (event) => {
            if (event.target === rulesModal) rulesModal.classList.remove('visible');
        });

        const aiButton = getEl('ai-button');
        const aiModal = getEl('aiModal');
        const closeAiButton = getEl('close-ai-button');
        aiButton.onclick = generateAiHelp;
        closeAiButton.onclick = () => aiModal.classList.remove('visible');
        aiModal.addEventListener('click', (e) => { if(e.target === aiModal) aiModal.classList.remove('visible'); });

        const quitConfirmModal = getEl('quitConfirmModal');
        const quitConfirmYes = getEl('quitConfirmYes');
        const quitConfirmNo = getEl('quitConfirmNo');
        quitConfirmNo.onclick = () => quitConfirmModal.classList.remove('visible');
        quitConfirmYes.onclick = () => {
            quitConfirmModal.classList.remove('visible');
            setWinner('p2', 'You have forfeited the game.');
        };
       
        initializeGame();
    </script>
</body>
</html>
